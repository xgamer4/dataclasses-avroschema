{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dataclasses Avro Schema Generator Generate Avro Schemas from a Python class Requirements python 3.7+ Installation pip install dataclasses-avroschema Usage Generating the avro schema import typing from dataclasses_avroschema import AvroModel , types class User ( AvroModel ): \"An User\" name : str age : int pets : typing . List [ str ] accounts : typing . Dict [ str , int ] favorite_colors : types . Enum = types . Enum ([ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]) country : str = \"Argentina\" address : str = None class Meta : namespace = \"User.v1\" aliases = [ \"user-v1\" , \"super user\" ] User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"namespace\" : \"User.v1\" , \"aliases\" : [ \"user-v1\" , \"super user\" ], \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"pets\" , \"type\" : \"array\" , \"items\" : \"string\" }, { \"name\" : \"accounts\" , \"type\" : \"map\" , \"values\" : \"int\" }, { \"name\" : \"favorite_colors\" , \"type\" : \"enum\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]}, { \"name\" : \"country\" , \"type\" : \"string\" , \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : null } ] } ' User . avro_schema_to_python () { \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"namespace\" : \"User.v1\" , \"aliases\" : [ \"user-v1\" , \"super user\" ], \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"pet\" }}, { \"name\" : \"accounts\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"int\" , \"name\" : \"account\" }}, { \"name\" : \"favorite_colors\" , \"type\" : { \"type\" : \"enum\" , \"name\" : \"favorite_color\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]}}, { \"name\" : \"country\" , \"type\" : \"string\" , \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : None } ], }","title":"Introduction"},{"location":"#dataclasses-avro-schema-generator","text":"Generate Avro Schemas from a Python class","title":"Dataclasses Avro Schema Generator"},{"location":"#requirements","text":"python 3.7+","title":"Requirements"},{"location":"#installation","text":"pip install dataclasses-avroschema","title":"Installation"},{"location":"#usage","text":"","title":"Usage"},{"location":"#generating-the-avro-schema","text":"import typing from dataclasses_avroschema import AvroModel , types class User ( AvroModel ): \"An User\" name : str age : int pets : typing . List [ str ] accounts : typing . Dict [ str , int ] favorite_colors : types . Enum = types . Enum ([ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]) country : str = \"Argentina\" address : str = None class Meta : namespace = \"User.v1\" aliases = [ \"user-v1\" , \"super user\" ] User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"namespace\" : \"User.v1\" , \"aliases\" : [ \"user-v1\" , \"super user\" ], \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"pets\" , \"type\" : \"array\" , \"items\" : \"string\" }, { \"name\" : \"accounts\" , \"type\" : \"map\" , \"values\" : \"int\" }, { \"name\" : \"favorite_colors\" , \"type\" : \"enum\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]}, { \"name\" : \"country\" , \"type\" : \"string\" , \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : null } ] } ' User . avro_schema_to_python () { \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"namespace\" : \"User.v1\" , \"aliases\" : [ \"user-v1\" , \"super user\" ], \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"pet\" }}, { \"name\" : \"accounts\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"int\" , \"name\" : \"account\" }}, { \"name\" : \"favorite_colors\" , \"type\" : { \"type\" : \"enum\" , \"name\" : \"favorite_color\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]}}, { \"name\" : \"country\" , \"type\" : \"string\" , \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : None } ], }","title":"Generating the avro schema"},{"location":"avro_schema/","text":"Avro Schemas and Python Class What is Apache Avro? Avro is a row-oriented remote procedure call and data serialization framework developed within Apache's Hadoop project. It uses JSON for defining data types and protocols, and serializes data in a compact binary format. Avro uses a schema to structure the data that is being encoded. It has two different types of schema languages; one for human editing (Avro IDL) and another which is more machine-readable based on (JSON) Goal Our goal is to come up with an avro schema from Python classes . We can think a avro Record as an analogous to a python class , but first, let's explaine what a record is. Records Records are one of the Complex Types in avro. It use the type name record and support three attributes. name: a JSON string providing the name of the record (required). namespace: a JSON string that qualifies the name; doc: a JSON string providing documentation to the user of this schema (optional). aliases: a JSON array of strings, providing alternate names for this record (optional). fields: a JSON array, listing fields (required). Each field is a JSON object with the following attributes: name: a JSON string providing the name of the field (required), and doc: a JSON string describing this field for users (optional). type: A JSON object defining a schema, or a JSON string naming a record definition (required). default: A default value for this field, used when reading instances that lack this field (optional). Permitted values depend on the field's schema type, according to the table below. Default values for union fields correspond to the first schema in the union. Default values for bytes and fixed fields are JSON strings, where Unicode code points 0-255 are mapped to unsigned 8-bit byte values 0-255. order: specifies how this field impacts sort ordering of this record (optional). Valid values are \"ascending\" (the default), \"descending\", or \"ignore\". For more details on how this is used, see the the sort order section below. aliases: a JSON array of strings, providing alternate names for this field (optional). For example, a User may be defined with: { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" }, { \"name\" : \"money\" , \"type\" : \"float\" } ] } From a Python class to the Avo Schema Image that you have to define the previous User schema but you do not know avro, you know python: from dataclasses_avroschema import AvroModel class User ( AvroModel ): name : str age : int has_pets : bool money : float User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" }, { \"name\" : \"money\" , \"type\" : \"float\" } ], \"doc\" : \"User(name: str, age: int, has_pets: bool, money: float)\" } ' and that is it!! Each python field is related with a avro type. You can find the field relationships here :","title":"Avro Schema and Python Classes"},{"location":"avro_schema/#avro-schemas-and-python-class","text":"","title":"Avro Schemas and Python Class"},{"location":"avro_schema/#what-is-apache-avro","text":"Avro is a row-oriented remote procedure call and data serialization framework developed within Apache's Hadoop project. It uses JSON for defining data types and protocols, and serializes data in a compact binary format. Avro uses a schema to structure the data that is being encoded. It has two different types of schema languages; one for human editing (Avro IDL) and another which is more machine-readable based on (JSON)","title":"What is Apache Avro?"},{"location":"avro_schema/#goal","text":"Our goal is to come up with an avro schema from Python classes . We can think a avro Record as an analogous to a python class , but first, let's explaine what a record is.","title":"Goal"},{"location":"avro_schema/#records","text":"Records are one of the Complex Types in avro. It use the type name record and support three attributes. name: a JSON string providing the name of the record (required). namespace: a JSON string that qualifies the name; doc: a JSON string providing documentation to the user of this schema (optional). aliases: a JSON array of strings, providing alternate names for this record (optional). fields: a JSON array, listing fields (required). Each field is a JSON object with the following attributes: name: a JSON string providing the name of the field (required), and doc: a JSON string describing this field for users (optional). type: A JSON object defining a schema, or a JSON string naming a record definition (required). default: A default value for this field, used when reading instances that lack this field (optional). Permitted values depend on the field's schema type, according to the table below. Default values for union fields correspond to the first schema in the union. Default values for bytes and fixed fields are JSON strings, where Unicode code points 0-255 are mapped to unsigned 8-bit byte values 0-255. order: specifies how this field impacts sort ordering of this record (optional). Valid values are \"ascending\" (the default), \"descending\", or \"ignore\". For more details on how this is used, see the the sort order section below. aliases: a JSON array of strings, providing alternate names for this field (optional). For example, a User may be defined with: { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" }, { \"name\" : \"money\" , \"type\" : \"float\" } ] }","title":"Records"},{"location":"avro_schema/#from-a-python-class-to-the-avo-schema","text":"Image that you have to define the previous User schema but you do not know avro, you know python: from dataclasses_avroschema import AvroModel class User ( AvroModel ): name : str age : int has_pets : bool money : float User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" }, { \"name\" : \"money\" , \"type\" : \"float\" } ], \"doc\" : \"User(name: str, age: int, has_pets: bool, money: float)\" } ' and that is it!! Each python field is related with a avro type. You can find the field relationships here :","title":"From a Python class to the Avo Schema"},{"location":"complex_types/","text":"Complex Types The following list represent the avro complext types mapped to python types: Avro Type Python Type enums types.Enum arrays typing.List, typing.Tuple, typing.Sequence, typing.MutableSequence maps typing.Dict, typing.Mapping, typing.MutableMapping fixed types.Fixed unions typing.Union unions with null typing.Optional records Python Class Enums Example: import typing from dataclasses_avroschema import AvroModel , types class User ( AvroModel ): \"An User\" favorite_colors : types . Enum = types . Enum ([ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], default = \"BLUE\" ) User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"favorite_colors\" , \"type\" : { \"type\" : \"enum\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], \"name\" : \"favorite_color\" }, \"default\" : \"BLUE\" } ], \"doc\" : \"An User\" } ' Arrays Example: import dataclasses import typing from dataclasses_avroschema import AvroModel class UserAdvance ( AvroModel ): \"User advanced\" pets : typing . List [ str ] cars : typing . List [ str ] = None favourites_numbers : typing . List [ int ] = dataclasses . field ( default_factory = lambda : [ 7 , 13 ]) UserAdvance . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"pet\" } }, { \"name\" : \"cars\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"car\" }, \"default\" : [] }, { \"name\" : \"favourites_numbers\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"int\" , \"name\" : \"favourites_number\" }, \"default\" : [ 7 , 13 ] } ], \"doc\" : \"User advanced\" } ' Maps Example: import dataclasses import typing from dataclasses_avroschema import AvroModel class UserAdvance ( AvroModel ): \"User advanced\" accounts_money : typing . Dict [ str , float ] cars_brand_total : typing . Dict [ str , int ] = None family_ages : typing . Dict [ str , int ] = dataclasses . field ( default_factory = lambda : { \"father\" : 50 }) UserAdvance . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"accounts_money\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"float\" , \"name\" : \"accounts_money\" } }, { \"name\" : \"cars_brand_total\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"int\" , \"name\" : \"cars_brand_total\" }, \"default\" : {} }, { \"name\" : \"family_ages\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"int\" , \"name\" : \"family_age\" }, \"default\" : { \"father\" : 50 } } ], \"doc\" : \"User advanced\" } ' Fixed import typing from dataclasses_avroschema import AvroModel , types class UserAdvance ( AvroModel ): name : str md5 : types . Fixed = types . Fixed ( 16 , namespace = 'md5' , aliases = [ \"md5\" , \"hash\" ]) UnionSchema . avro_schema () { 'type' : 'record' , 'name' : 'UserAdvance' , 'fields' : [ { 'name' : 'name' , 'type' : 'string' }, { 'name' : 'md5' , 'type' : { 'type' : 'fixed' , 'name' : 'md5' , 'size' : 16 , 'namespace' : 'md5' , 'aliases' : [ 'md5' , 'hash' ]}} ], 'doc' : 'UserAdvance(name: str, md5: dataclasses_avroschema.types.Fixed = 16)' } Unions import typing import dataclasses import datetime import uuid from dataclasses_avroschema import AvroModel class UnionSchema ( AvroModel ): \"Some Unions\" first_union : typing . Union [ str , int ] logical_union : typing . Union [ datetime . datetime , datetime . date , uuid . uuid4 ] second_union : typing . Union [ str , int ] = dataclasses . field ( default_factory = lambda : [ \"test\" ]) UnionSchema . avro_schema () { \"type\" : \"record\" , \"name\" : \"UnionSchema\" , \"fields\" : [ { \"name\" : \"first_union\" , \"type\" : [ \"string\" , \"int\" ]}, { \"name\" : \"logical_union\" , \"type\" : [ { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" }, { \"type\" : \"int\" , \"logicalType\" : \"date\" }, { \"type\" : \"string\" , \"logicalType\" : \"uuid\" }]}, { \"name\" : \"second_union\" , \"type\" : [ \"string\" , \"int\" ], \"default\" : [ \"test\" ]}], \"doc\" : \"Some Unions\" } # Union with Records class Bus ( AvroModel ): \"A Bus\" engine_name : str class Car ( AvroModel ): \"A Car\" engine_name : str class UnionSchema ( AvroModel ): \"Some Unions\" lake_trip : typing . Union [ Bus , Car ] river_trip : typing . Union [ Bus , Car ] = None mountain_trip : typing . Union [ Bus , Car ] = dataclasses . field ( default_factory = lambda : { \"engine_name\" : \"honda\" }) UnionSchema . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UnionSchema\" , \"fields\" : [ { \"name\" : \"lake_trip\" , \"type\" : [ { \"type\" : \"record\" , \"name\" : \"Bus\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Bus\" }, { \"type\" : \"record\" , \"name\" : \"Car\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Car\" } ] }, { \"name\" : \"river_trip\" , \"type\" : [ \"null\" , { \"type\" : \"record\" , \"name\" : \"Bus\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Bus\" }, { \"type\" : \"record\" , \"name\" : \"Car\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Car\" } ], \"default\" : null }, { \"name\" : \"mountain_trip\" , \"type\" : [ { \"type\" : \"record\" , \"name\" : \"Bus\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Bus\" }, { \"type\" : \"record\" , \"name\" : \"Car\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Car\" } ], \"default\" : { \"engine_name\" : \"honda\" } } ], \"doc\" : \"Some Unions\" } ' Unions with typing.Optional typing.Optional[Any] is translated as an optional Union: typing.Union[Any, NoneType] where NoneType is always at the end import typing import dataclasses from dataclasses_avroschema import AvroModel from dataclasses import dataclass , field @dataclasses . dataclass class X ( AvroModel ): y : typing . Optional [ typing . List [ int ]] X . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"X\" , \"fields\" : [ { \"name\" : \"y\" , \"type\" : [{ \"type\" : \"array\" , \"items\" : \"int\" , \"name\" : \"y\" }, \"null\" ]} ], \"doc\" : \"X(y: Union[List[int], NoneType])\" } ' Records Mapped as a Python class There are some special avro attributes like aliases , namespace and doc (both not required) that can be specified in a record type. The doc attribute can be set via the docstring class. The aliases and namespaces must be set using the extra_avro_attributes static method. from dataclasses_avroschema import AvroModel class User ( AvroModel ): \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 class Meta : namespace = \"test.com.ar/user/v1\" aliases = [ \"User\" , \"My favorite User\" ] User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" , \"default\" : false }, { \"name\" : \"money\" , \"type\" : \"float\" , \"default\" : 100.3 } ], \"doc\" : \"My User Class\" , \"namespace\" : \"test.com.ar/user/v1\" , \"aliases\" : [ \"User\" , \"My favorite User\" ] } ' Class Meta The class Meta is used to specify schema attributes that are not reprsented by the class fields like namespace , aliases and whether include the schema documentation . class Meta : schema_doc = False namespace = \"test.com.ar/user/v1\" aliases = [ \"User\" , \"My favorite User\" ] schema_doc (boolean) : Whether include the schema documentation generated from docstrings . Default True namespace (optional[str]) : Schema namespace. Default None aliases (optional[List[str]]) : Schema aliases. Default None","title":"Complex Types"},{"location":"complex_types/#complex-types","text":"The following list represent the avro complext types mapped to python types: Avro Type Python Type enums types.Enum arrays typing.List, typing.Tuple, typing.Sequence, typing.MutableSequence maps typing.Dict, typing.Mapping, typing.MutableMapping fixed types.Fixed unions typing.Union unions with null typing.Optional records Python Class","title":"Complex Types"},{"location":"complex_types/#enums","text":"Example: import typing from dataclasses_avroschema import AvroModel , types class User ( AvroModel ): \"An User\" favorite_colors : types . Enum = types . Enum ([ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], default = \"BLUE\" ) User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"favorite_colors\" , \"type\" : { \"type\" : \"enum\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], \"name\" : \"favorite_color\" }, \"default\" : \"BLUE\" } ], \"doc\" : \"An User\" } '","title":"Enums"},{"location":"complex_types/#arrays","text":"Example: import dataclasses import typing from dataclasses_avroschema import AvroModel class UserAdvance ( AvroModel ): \"User advanced\" pets : typing . List [ str ] cars : typing . List [ str ] = None favourites_numbers : typing . List [ int ] = dataclasses . field ( default_factory = lambda : [ 7 , 13 ]) UserAdvance . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"pet\" } }, { \"name\" : \"cars\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"car\" }, \"default\" : [] }, { \"name\" : \"favourites_numbers\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"int\" , \"name\" : \"favourites_number\" }, \"default\" : [ 7 , 13 ] } ], \"doc\" : \"User advanced\" } '","title":"Arrays"},{"location":"complex_types/#maps","text":"Example: import dataclasses import typing from dataclasses_avroschema import AvroModel class UserAdvance ( AvroModel ): \"User advanced\" accounts_money : typing . Dict [ str , float ] cars_brand_total : typing . Dict [ str , int ] = None family_ages : typing . Dict [ str , int ] = dataclasses . field ( default_factory = lambda : { \"father\" : 50 }) UserAdvance . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"accounts_money\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"float\" , \"name\" : \"accounts_money\" } }, { \"name\" : \"cars_brand_total\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"int\" , \"name\" : \"cars_brand_total\" }, \"default\" : {} }, { \"name\" : \"family_ages\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"int\" , \"name\" : \"family_age\" }, \"default\" : { \"father\" : 50 } } ], \"doc\" : \"User advanced\" } '","title":"Maps"},{"location":"complex_types/#fixed","text":"import typing from dataclasses_avroschema import AvroModel , types class UserAdvance ( AvroModel ): name : str md5 : types . Fixed = types . Fixed ( 16 , namespace = 'md5' , aliases = [ \"md5\" , \"hash\" ]) UnionSchema . avro_schema () { 'type' : 'record' , 'name' : 'UserAdvance' , 'fields' : [ { 'name' : 'name' , 'type' : 'string' }, { 'name' : 'md5' , 'type' : { 'type' : 'fixed' , 'name' : 'md5' , 'size' : 16 , 'namespace' : 'md5' , 'aliases' : [ 'md5' , 'hash' ]}} ], 'doc' : 'UserAdvance(name: str, md5: dataclasses_avroschema.types.Fixed = 16)' }","title":"Fixed"},{"location":"complex_types/#unions","text":"import typing import dataclasses import datetime import uuid from dataclasses_avroschema import AvroModel class UnionSchema ( AvroModel ): \"Some Unions\" first_union : typing . Union [ str , int ] logical_union : typing . Union [ datetime . datetime , datetime . date , uuid . uuid4 ] second_union : typing . Union [ str , int ] = dataclasses . field ( default_factory = lambda : [ \"test\" ]) UnionSchema . avro_schema () { \"type\" : \"record\" , \"name\" : \"UnionSchema\" , \"fields\" : [ { \"name\" : \"first_union\" , \"type\" : [ \"string\" , \"int\" ]}, { \"name\" : \"logical_union\" , \"type\" : [ { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" }, { \"type\" : \"int\" , \"logicalType\" : \"date\" }, { \"type\" : \"string\" , \"logicalType\" : \"uuid\" }]}, { \"name\" : \"second_union\" , \"type\" : [ \"string\" , \"int\" ], \"default\" : [ \"test\" ]}], \"doc\" : \"Some Unions\" } # Union with Records class Bus ( AvroModel ): \"A Bus\" engine_name : str class Car ( AvroModel ): \"A Car\" engine_name : str class UnionSchema ( AvroModel ): \"Some Unions\" lake_trip : typing . Union [ Bus , Car ] river_trip : typing . Union [ Bus , Car ] = None mountain_trip : typing . Union [ Bus , Car ] = dataclasses . field ( default_factory = lambda : { \"engine_name\" : \"honda\" }) UnionSchema . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UnionSchema\" , \"fields\" : [ { \"name\" : \"lake_trip\" , \"type\" : [ { \"type\" : \"record\" , \"name\" : \"Bus\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Bus\" }, { \"type\" : \"record\" , \"name\" : \"Car\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Car\" } ] }, { \"name\" : \"river_trip\" , \"type\" : [ \"null\" , { \"type\" : \"record\" , \"name\" : \"Bus\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Bus\" }, { \"type\" : \"record\" , \"name\" : \"Car\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Car\" } ], \"default\" : null }, { \"name\" : \"mountain_trip\" , \"type\" : [ { \"type\" : \"record\" , \"name\" : \"Bus\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Bus\" }, { \"type\" : \"record\" , \"name\" : \"Car\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Car\" } ], \"default\" : { \"engine_name\" : \"honda\" } } ], \"doc\" : \"Some Unions\" } '","title":"Unions"},{"location":"complex_types/#unions-with-typingoptional","text":"typing.Optional[Any] is translated as an optional Union: typing.Union[Any, NoneType] where NoneType is always at the end import typing import dataclasses from dataclasses_avroschema import AvroModel from dataclasses import dataclass , field @dataclasses . dataclass class X ( AvroModel ): y : typing . Optional [ typing . List [ int ]] X . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"X\" , \"fields\" : [ { \"name\" : \"y\" , \"type\" : [{ \"type\" : \"array\" , \"items\" : \"int\" , \"name\" : \"y\" }, \"null\" ]} ], \"doc\" : \"X(y: Union[List[int], NoneType])\" } '","title":"Unions with typing.Optional"},{"location":"complex_types/#records","text":"Mapped as a Python class There are some special avro attributes like aliases , namespace and doc (both not required) that can be specified in a record type. The doc attribute can be set via the docstring class. The aliases and namespaces must be set using the extra_avro_attributes static method. from dataclasses_avroschema import AvroModel class User ( AvroModel ): \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 class Meta : namespace = \"test.com.ar/user/v1\" aliases = [ \"User\" , \"My favorite User\" ] User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" , \"default\" : false }, { \"name\" : \"money\" , \"type\" : \"float\" , \"default\" : 100.3 } ], \"doc\" : \"My User Class\" , \"namespace\" : \"test.com.ar/user/v1\" , \"aliases\" : [ \"User\" , \"My favorite User\" ] } '","title":"Records"},{"location":"complex_types/#class-meta","text":"The class Meta is used to specify schema attributes that are not reprsented by the class fields like namespace , aliases and whether include the schema documentation . class Meta : schema_doc = False namespace = \"test.com.ar/user/v1\" aliases = [ \"User\" , \"My favorite User\" ] schema_doc (boolean) : Whether include the schema documentation generated from docstrings . Default True namespace (optional[str]) : Schema namespace. Default None aliases (optional[List[str]]) : Schema aliases. Default None","title":"Class Meta"},{"location":"faust_records/","text":"This library also has support to generate Avro Schemas from a faust.Record Example: import faust import dataclasses import typing from dataclasses_avroschema import AvroModel class UserAdvance ( faust . Record , AvroModel ): name : str age : int pets : typing . List [ str ] = dataclasses . field ( default_factory = lambda : [ 'dog' , 'cat' ]) accounts : typing . Dict [ str , int ] = dataclasses . field ( default_factory = lambda : { \"key\" : 1 }) has_car : bool = False favorite_colors : typing . Tuple [ str ] = ( \"BLUE\" , \"YELLOW\" , \"GREEN\" ) country : str = \"Argentina\" address : str = None class Meta : schema_doc = False UserAdvance . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"pet\" }, \"default\" : [ \"dog\" , \"cat\" ] }, { \"name\" : \"accounts\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"int\" , \"name\" : \"account\" }, \"default\" : { \"key\" : 1 } }, { \"name\" : \"has_car\" , \"type\" : \"boolean\" , \"default\" : false }, { \"name\" : \"favorite_colors\" , \"type\" : { \"type\" : \"enum\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], \"name\" : \"favorite_color\" } }, { \"name\" : \"country\" , \"type\" : \"string\" , \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : null } ] } '","title":"Faust Records"},{"location":"fields_specification/","text":"Apache Avro has Primitive Types , Complex Types and Logical Types , so we need to match these types with python types. Primitive Types and python representation The set of primitive type names is: null: no value boolean: a binary value int: 32-bit signed integer long: 64-bit signed integer float: single precision (32-bit) IEEE 754 floating-point number double: double precision (64-bit) IEEE 754 floating-point number bytes: sequence of 8-bit unsigned bytes string: unicode character sequence So, the previous types can be matched to: Avro Type Python Type string str int int boolean bool float float null None bytes bytes Complex Types Avro supports six kinds of complex types: enums, arrays, maps, fixed, unions and records. Avro Type Python Type enums tuple arrays list maps dict fixed types.Fixed unions typing.Union records Python Class Enums: Use the type name \"enum\" and support the following attributes: name: a JSON string providing the name of the enum (required). namespace: a JSON string that qualifies the name; aliases: a JSON array of strings, providing alternate names for this enum (optional). doc: a JSON string providing documentation to the user of this schema (optional). symbols: a JSON array, listing symbols, as JSON strings (required). All symbols in an enum must be unique; duplicates are prohibited. Every symbol must match the regular expression [A-Za-z_][A-Za-z0-9_]* (the same requirement as for names). When we want to define a enum type we should specify a default value because we need to define the symbols In future version we will have a custom enum type to avoid this Arrays: Use the type name \"array\" and support the following attribute: name: a JSON string providing the name of the enum (required). items: the schema of the array's items. Maps: Use the type name \"map\". Map keys are assumed to be string. Support the following attribute: name: a JSON string providing the name of the enum (required). values: the schema of the map's values. Fixed uses the type name \"fixed\" and supports two attributes: name: a string naming this fixed (required). namespace, a string that qualifies the name; aliases: a JSON array of strings, providing alternate names for this enum (optional). size: an integer, specifying the number of bytes per value (required). Unions: Unions are represented using JSON arrays. For example, [\"null\", \"string\"] declares a schema which may be either a null or string. Records: Records use the type name record and will represent the Schema . Logical Types A logical type is an Avro primitive or complex type with extra attributes to represent a derived type. The attribute logicalType must always be present for a logical type, and is a string with the name of one of the logical types listed later in this section. Other attributes may be defined for particular logical types. A logical type is always serialized using its underlying Avro type so that values are encoded in exactly the same way as the equivalent Avro type that does not have a logicalType attribute. Language implementations may choose to represent logical types with an appropriate native type, although this is not required. Language implementations must ignore unknown logical types when reading, and should use the underlying Avro type. If a logical type is invalid, for example a decimal with scale greater than its precision, then implementations should ignore the logical type and use the underlying Avro type. Date: The date logical type represents a date within the calendar, with no reference to a particular time zone or time of day. A date logical type annotates an Avro int, where the int stores the number of days from the unix epoch, 1 January 1970 (ISO calendar). Time (millisecond precision): The time-millis logical type represents a time of day, with no reference to a particular calendar, time zone or date, with a precision of one millisecond. A time-millis logical type annotates an Avro int, where the int stores the number of milliseconds after midnight, 00:00:00.000. Timestamp (millisecond precision): The timestamp-millis logical type represents an instant on the global timeline, independent of a particular time zone or calendar, with a precision of one millisecond. A timestamp-millis logical type annotates an Avro long, where the long stores the number of milliseconds from the unix epoch, 1 January 1970 00:00:00.000 UTC. UUID: Represents a uuid as a string Avro Type Logical Type Python Type int date datetime.date int time-millis datetime.time long timestamp-millis datetime.datetime string uuid uuid.uuid4 string uuid uuid.UUID Avro Field and Python Types Summary Python Type Avro Type Logical Type str string do not apply int int do not apply bool boolean do not apply float float do not apply None null do not apply bytes bytes do not apply typing.List array do not apply typing.Tuple array do not apply typing.Sequence array do not apply typing.MutableSequence array do not apply typing.Dict map do not apply typing.Mapping map do not apply typing.MutableMapping map do not apply types.Fixed fixed do not apply types.Enum enum do not apply typing.Union union do not apply typing.Optional union (with null ) do not apply Pythin classs record do not apply datetime.date int date datetime.time int time-millis datetime.datetim long timestamp-millis uuid.uuid4 string uuid Adding Custom Field-level Attributes You may want to add field-level attributes which are not automatically populated according to the typing semantics listed above. For example, you might want a \"doc\" attribute or even a custom attribute (which Avro supports as long as it doesn't conflict with any field names in the core Avro specification). An example of a custom attribute is a flag for whether a field contains sensitive data. e.g. \"sensitivty\" . When your Python class is serialised to Avro, each field will contain a number of attributes. Some of these of are common to all fields such as \"name\" and others are specific to the datatype (e.g. array will have the items attribute). In order to add custom fields, you can use the field descriptor of the built-in dataclasses package and provide a dict of key-value pairs to the metadata parameter as in dataclasses.field(metadata={'doc': 'foo'}) . Examples Adding a doc attribute to fields. from dataclasses import dataclass , field from dataclasses_avroschema import AvroModel , types @dataclass class User ( AvroModel ): \"An User\" name : str = field ( metadata = { 'doc' : 'bar' }) age : int = field ( metadata = { 'doc' : 'foo' }) User . avro_schema () { \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" , \"doc\" : \"bar\" }, { \"name\" : \"age\" , \"type\" : \"int\" , \"doc\" : \"foo\" } ] } Adding an additional sensitivity attribute to fields. from dataclasses import dataclass , field from dataclasses_avroschema import AvroModel , types @dataclass class User ( AvroModel ): \"An User\" name : str = field ( metadata = { 'doc' : 'bar' , 'sensitivity' : 'HIGH' }) age : int = field ( metadata = { 'doc' : 'foo' , 'sensitivity' : 'MEDIUM' }) User . avro_schema () { \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" , \"doc\" : \"bar\" , \"sensitivity\" : \"HIGH\" }, { \"name\" : \"age\" , \"type\" : \"int\" , \"doc\" : \"foo\" , \"sensitivity\" : \"MEDIUM\" } ] }","title":"Fields Specification"},{"location":"fields_specification/#primitive-types-and-python-representation","text":"The set of primitive type names is: null: no value boolean: a binary value int: 32-bit signed integer long: 64-bit signed integer float: single precision (32-bit) IEEE 754 floating-point number double: double precision (64-bit) IEEE 754 floating-point number bytes: sequence of 8-bit unsigned bytes string: unicode character sequence So, the previous types can be matched to: Avro Type Python Type string str int int boolean bool float float null None bytes bytes","title":"Primitive Types and python representation"},{"location":"fields_specification/#complex-types","text":"Avro supports six kinds of complex types: enums, arrays, maps, fixed, unions and records. Avro Type Python Type enums tuple arrays list maps dict fixed types.Fixed unions typing.Union records Python Class Enums: Use the type name \"enum\" and support the following attributes: name: a JSON string providing the name of the enum (required). namespace: a JSON string that qualifies the name; aliases: a JSON array of strings, providing alternate names for this enum (optional). doc: a JSON string providing documentation to the user of this schema (optional). symbols: a JSON array, listing symbols, as JSON strings (required). All symbols in an enum must be unique; duplicates are prohibited. Every symbol must match the regular expression [A-Za-z_][A-Za-z0-9_]* (the same requirement as for names). When we want to define a enum type we should specify a default value because we need to define the symbols In future version we will have a custom enum type to avoid this Arrays: Use the type name \"array\" and support the following attribute: name: a JSON string providing the name of the enum (required). items: the schema of the array's items. Maps: Use the type name \"map\". Map keys are assumed to be string. Support the following attribute: name: a JSON string providing the name of the enum (required). values: the schema of the map's values. Fixed uses the type name \"fixed\" and supports two attributes: name: a string naming this fixed (required). namespace, a string that qualifies the name; aliases: a JSON array of strings, providing alternate names for this enum (optional). size: an integer, specifying the number of bytes per value (required). Unions: Unions are represented using JSON arrays. For example, [\"null\", \"string\"] declares a schema which may be either a null or string. Records: Records use the type name record and will represent the Schema .","title":"Complex Types"},{"location":"fields_specification/#logical-types","text":"A logical type is an Avro primitive or complex type with extra attributes to represent a derived type. The attribute logicalType must always be present for a logical type, and is a string with the name of one of the logical types listed later in this section. Other attributes may be defined for particular logical types. A logical type is always serialized using its underlying Avro type so that values are encoded in exactly the same way as the equivalent Avro type that does not have a logicalType attribute. Language implementations may choose to represent logical types with an appropriate native type, although this is not required. Language implementations must ignore unknown logical types when reading, and should use the underlying Avro type. If a logical type is invalid, for example a decimal with scale greater than its precision, then implementations should ignore the logical type and use the underlying Avro type. Date: The date logical type represents a date within the calendar, with no reference to a particular time zone or time of day. A date logical type annotates an Avro int, where the int stores the number of days from the unix epoch, 1 January 1970 (ISO calendar). Time (millisecond precision): The time-millis logical type represents a time of day, with no reference to a particular calendar, time zone or date, with a precision of one millisecond. A time-millis logical type annotates an Avro int, where the int stores the number of milliseconds after midnight, 00:00:00.000. Timestamp (millisecond precision): The timestamp-millis logical type represents an instant on the global timeline, independent of a particular time zone or calendar, with a precision of one millisecond. A timestamp-millis logical type annotates an Avro long, where the long stores the number of milliseconds from the unix epoch, 1 January 1970 00:00:00.000 UTC. UUID: Represents a uuid as a string Avro Type Logical Type Python Type int date datetime.date int time-millis datetime.time long timestamp-millis datetime.datetime string uuid uuid.uuid4 string uuid uuid.UUID","title":"Logical Types"},{"location":"fields_specification/#avro-field-and-python-types-summary","text":"Python Type Avro Type Logical Type str string do not apply int int do not apply bool boolean do not apply float float do not apply None null do not apply bytes bytes do not apply typing.List array do not apply typing.Tuple array do not apply typing.Sequence array do not apply typing.MutableSequence array do not apply typing.Dict map do not apply typing.Mapping map do not apply typing.MutableMapping map do not apply types.Fixed fixed do not apply types.Enum enum do not apply typing.Union union do not apply typing.Optional union (with null ) do not apply Pythin classs record do not apply datetime.date int date datetime.time int time-millis datetime.datetim long timestamp-millis uuid.uuid4 string uuid","title":"Avro Field and Python Types Summary"},{"location":"fields_specification/#adding-custom-field-level-attributes","text":"You may want to add field-level attributes which are not automatically populated according to the typing semantics listed above. For example, you might want a \"doc\" attribute or even a custom attribute (which Avro supports as long as it doesn't conflict with any field names in the core Avro specification). An example of a custom attribute is a flag for whether a field contains sensitive data. e.g. \"sensitivty\" . When your Python class is serialised to Avro, each field will contain a number of attributes. Some of these of are common to all fields such as \"name\" and others are specific to the datatype (e.g. array will have the items attribute). In order to add custom fields, you can use the field descriptor of the built-in dataclasses package and provide a dict of key-value pairs to the metadata parameter as in dataclasses.field(metadata={'doc': 'foo'}) .","title":"Adding Custom Field-level Attributes"},{"location":"fields_specification/#examples","text":"Adding a doc attribute to fields. from dataclasses import dataclass , field from dataclasses_avroschema import AvroModel , types @dataclass class User ( AvroModel ): \"An User\" name : str = field ( metadata = { 'doc' : 'bar' }) age : int = field ( metadata = { 'doc' : 'foo' }) User . avro_schema () { \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" , \"doc\" : \"bar\" }, { \"name\" : \"age\" , \"type\" : \"int\" , \"doc\" : \"foo\" } ] } Adding an additional sensitivity attribute to fields. from dataclasses import dataclass , field from dataclasses_avroschema import AvroModel , types @dataclass class User ( AvroModel ): \"An User\" name : str = field ( metadata = { 'doc' : 'bar' , 'sensitivity' : 'HIGH' }) age : int = field ( metadata = { 'doc' : 'foo' , 'sensitivity' : 'MEDIUM' }) User . avro_schema () { \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" , \"doc\" : \"bar\" , \"sensitivity\" : \"HIGH\" }, { \"name\" : \"age\" , \"type\" : \"int\" , \"doc\" : \"foo\" , \"sensitivity\" : \"MEDIUM\" } ] }","title":"Examples"},{"location":"kafka_examples/","text":"Under examples folder you can find 3 differents examples, one with aiokafka ( async ) showing the simplest use case when a AvroModel instance is serialized and sent it thorught kafka, and the event is consumed. The other two examples are sync using the kafka-python driver, where the avro-json serialization and schema evolution ( FULL compatibility) is shown. Minimal example import asyncio from dataclasses import dataclass import random from aiokafka import AIOKafkaConsumer , AIOKafkaProducer from dataclasses_avroschema import AvroModel , types @dataclass class UserModel ( AvroModel ): \"An User\" name : str age : int favorite_colors : types . Enum = types . Enum ([ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], default = \"BLUE\" ) country : str = \"Argentina\" address : str = None class Meta : namespace = \"User.v1\" aliases = [ \"user-v1\" , \"super user\" ] async def consume ( loop , total_events = 10 ): consumer = AIOKafkaConsumer ( 'my_topic' , 'my_other_topic' , loop = loop , bootstrap_servers = 'localhost:9092' , group_id = \"my-group\" ) # Get cluster layout and join group `my-group` await consumer . start () run_consumer = True while run_consumer : try : # Consume messages async for msg in consumer : print ( f \"Message received: { msg . value } at { msg . timestamp } \" ) user = UserModel . deserialize ( msg . value ) print ( f \"Message deserialized: { user } \" ) except KeyboardInterrupt : # Will leave consumer group; perform autocommit if enabled. await consumer . stop () print ( \"Stoping consumer...\" ) run_consumer = False async def send ( loop , total_events = 10 ): producer = AIOKafkaProducer ( loop = loop , bootstrap_servers = 'localhost:9092' ) # Get cluster layout and initial topic/partition leadership information await producer . start () for event_number in range ( 1 , total_events + 1 ): # Produce message print ( f \"Sending event number { event_number } \" ) user = UserModel ( name = random . choice ([ \"Juan\" , \"Peter\" , \"Michael\" , \"Moby\" , \"Kim\" ,]), age = random . randint ( 1 , 50 ) ) # create the message message = user . serialize () await producer . send_and_wait ( \"my_topic\" , message ) # sleep for 2 seconds await asyncio . sleep ( 2 ) else : # Wait for all pending messages to be delivered or expire. await producer . stop () print ( \"Stoping producer...\" ) if __name__ == \"__main__\" : loop = asyncio . get_event_loop () tasks = asyncio . gather ( send ( loop ), consume ( loop )) loop . run_until_complete ( tasks )","title":"Kafka examples"},{"location":"kafka_examples/#minimal-example","text":"import asyncio from dataclasses import dataclass import random from aiokafka import AIOKafkaConsumer , AIOKafkaProducer from dataclasses_avroschema import AvroModel , types @dataclass class UserModel ( AvroModel ): \"An User\" name : str age : int favorite_colors : types . Enum = types . Enum ([ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], default = \"BLUE\" ) country : str = \"Argentina\" address : str = None class Meta : namespace = \"User.v1\" aliases = [ \"user-v1\" , \"super user\" ] async def consume ( loop , total_events = 10 ): consumer = AIOKafkaConsumer ( 'my_topic' , 'my_other_topic' , loop = loop , bootstrap_servers = 'localhost:9092' , group_id = \"my-group\" ) # Get cluster layout and join group `my-group` await consumer . start () run_consumer = True while run_consumer : try : # Consume messages async for msg in consumer : print ( f \"Message received: { msg . value } at { msg . timestamp } \" ) user = UserModel . deserialize ( msg . value ) print ( f \"Message deserialized: { user } \" ) except KeyboardInterrupt : # Will leave consumer group; perform autocommit if enabled. await consumer . stop () print ( \"Stoping consumer...\" ) run_consumer = False async def send ( loop , total_events = 10 ): producer = AIOKafkaProducer ( loop = loop , bootstrap_servers = 'localhost:9092' ) # Get cluster layout and initial topic/partition leadership information await producer . start () for event_number in range ( 1 , total_events + 1 ): # Produce message print ( f \"Sending event number { event_number } \" ) user = UserModel ( name = random . choice ([ \"Juan\" , \"Peter\" , \"Michael\" , \"Moby\" , \"Kim\" ,]), age = random . randint ( 1 , 50 ) ) # create the message message = user . serialize () await producer . send_and_wait ( \"my_topic\" , message ) # sleep for 2 seconds await asyncio . sleep ( 2 ) else : # Wait for all pending messages to be delivered or expire. await producer . stop () print ( \"Stoping producer...\" ) if __name__ == \"__main__\" : loop = asyncio . get_event_loop () tasks = asyncio . gather ( send ( loop ), consume ( loop )) loop . run_until_complete ( tasks )","title":"Minimal example"},{"location":"logical_types/","text":"Schema with Logical Types The following list represent the avro logical types mapped to python types: Avro Type Logical Type Python Type int date datetime.date int time-millis datetime.time long timestamp-millis datetime.datetime string uuid uuid.uuid4 string uuid uuid.UUID Date import datetime from dataclasses_avroschema import AvroModel a_datetime = datetime . datetime ( 2019 , 10 , 12 , 17 , 57 , 42 ) class DateLogicalType ( AvroModel ): \"Date type\" birthday : datetime . date meeting_date : datetime . date = None release_datetime : datetime . date = a_datetime . date () DateLogicalType . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"DateLogicalType\" , \"fields\" : [ { \"name\" : \"birthday\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"date\" } }, { \"name\" : \"meeting_date\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"date\" }, \"default\" : null }, { \"name\" : \"release_datetime\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"date\" }, \"default\" : 18181 } ], \"doc\" : \"Date type\" } ' Time import datetime from dataclasses_avroschema import AvroModel a_datetime = datetime . datetime ( 2019 , 10 , 12 , 17 , 57 , 42 ) class TimeLogicalTypes ( AvroModel ): \"Time logical types\" birthday_time : datetime . time meeting_time : datetime . time = None release_time : datetime . time = a_datetime . time () TimeLogicalTypes . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"TimeLogicalTypes\" , \"fields\" : [ { \"name\" : \"birthday_time\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"time-millis\" } }, { \"name\" : \"meeting_time\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"time-millis\" }, \"default\" : null }, { \"name\" : \"release_time\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"time-millis\" }, \"default\" : 64662000 } ], \"doc\" : \"Time logical types\" } ' Datetime import datetime from dataclasses_avroschema import AvroModel a_datetime = datetime . datetime ( 2019 , 10 , 12 , 17 , 57 , 42 ) class DatetimeLogicalType ( AvroModel ): \"Datetime logical types\" birthday : datetime . datetime meeting_time : datetime . datetime = None release_datetime : datetime . datetime = a_datetime DatetimeLogicalType . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"DatetimeLogicalType\" , \"fields\" : [ { \"name\" : \"birthday\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" } }, { \"name\" : \"meeting_time\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" }, \"default\" : null }, { \"name\" : \"release_datetime\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" }, \"default\" : 1570903062000.0 } ], \"doc\" : \"Datetime logical types\" } ' UUID import uuid from dataclasses_avroschema import AvroModel class UUIDLogicalTypes ( AvroModel ): \"UUID logical types\" uuid_1 : uuid . uuid4 uuid_2 : uuid . uuid4 = None event_uuid : uuid . uuid4 = uuid . uuid4 () UUIDLogicalTypes . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UUIDLogicalTypes\" , \"fields\" : [ { \"name\" : \"uuid_1\" , \"type\" : { \"type\" : \"string\" , \"logicalType\" : \"uuid\" } }, { \"name\" : \"uuid_2\" , \"type\" : { \"type\" : \"string\" , \"logicalType\" : \"uuid\" }, \"default\" : null }, { \"name\" : \"event_uuid\" , \"type\" : { \"type\" : \"string\" , \"logicalType\" : \"uuid\" }, \"default\" : \"ad0677ab-bd1c-4383-9d45-e46c56bcc5c9\" } ], \"doc\" : \"UUID logical types\" } '","title":"Logical Types"},{"location":"logical_types/#schema-with-logical-types","text":"The following list represent the avro logical types mapped to python types: Avro Type Logical Type Python Type int date datetime.date int time-millis datetime.time long timestamp-millis datetime.datetime string uuid uuid.uuid4 string uuid uuid.UUID","title":"Schema with Logical Types"},{"location":"logical_types/#date","text":"import datetime from dataclasses_avroschema import AvroModel a_datetime = datetime . datetime ( 2019 , 10 , 12 , 17 , 57 , 42 ) class DateLogicalType ( AvroModel ): \"Date type\" birthday : datetime . date meeting_date : datetime . date = None release_datetime : datetime . date = a_datetime . date () DateLogicalType . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"DateLogicalType\" , \"fields\" : [ { \"name\" : \"birthday\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"date\" } }, { \"name\" : \"meeting_date\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"date\" }, \"default\" : null }, { \"name\" : \"release_datetime\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"date\" }, \"default\" : 18181 } ], \"doc\" : \"Date type\" } '","title":"Date"},{"location":"logical_types/#time","text":"import datetime from dataclasses_avroschema import AvroModel a_datetime = datetime . datetime ( 2019 , 10 , 12 , 17 , 57 , 42 ) class TimeLogicalTypes ( AvroModel ): \"Time logical types\" birthday_time : datetime . time meeting_time : datetime . time = None release_time : datetime . time = a_datetime . time () TimeLogicalTypes . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"TimeLogicalTypes\" , \"fields\" : [ { \"name\" : \"birthday_time\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"time-millis\" } }, { \"name\" : \"meeting_time\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"time-millis\" }, \"default\" : null }, { \"name\" : \"release_time\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"time-millis\" }, \"default\" : 64662000 } ], \"doc\" : \"Time logical types\" } '","title":"Time"},{"location":"logical_types/#datetime","text":"import datetime from dataclasses_avroschema import AvroModel a_datetime = datetime . datetime ( 2019 , 10 , 12 , 17 , 57 , 42 ) class DatetimeLogicalType ( AvroModel ): \"Datetime logical types\" birthday : datetime . datetime meeting_time : datetime . datetime = None release_datetime : datetime . datetime = a_datetime DatetimeLogicalType . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"DatetimeLogicalType\" , \"fields\" : [ { \"name\" : \"birthday\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" } }, { \"name\" : \"meeting_time\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" }, \"default\" : null }, { \"name\" : \"release_datetime\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" }, \"default\" : 1570903062000.0 } ], \"doc\" : \"Datetime logical types\" } '","title":"Datetime"},{"location":"logical_types/#uuid","text":"import uuid from dataclasses_avroschema import AvroModel class UUIDLogicalTypes ( AvroModel ): \"UUID logical types\" uuid_1 : uuid . uuid4 uuid_2 : uuid . uuid4 = None event_uuid : uuid . uuid4 = uuid . uuid4 () UUIDLogicalTypes . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UUIDLogicalTypes\" , \"fields\" : [ { \"name\" : \"uuid_1\" , \"type\" : { \"type\" : \"string\" , \"logicalType\" : \"uuid\" } }, { \"name\" : \"uuid_2\" , \"type\" : { \"type\" : \"string\" , \"logicalType\" : \"uuid\" }, \"default\" : null }, { \"name\" : \"event_uuid\" , \"type\" : { \"type\" : \"string\" , \"logicalType\" : \"uuid\" }, \"default\" : \"ad0677ab-bd1c-4383-9d45-e46c56bcc5c9\" } ], \"doc\" : \"UUID logical types\" } '","title":"UUID"},{"location":"migration_guide/","text":"Migration from previous versions to 0.14.0 Now all the dataclasses should inheritance from AvroModel and not use anymore the SchemaGenerator : # Versions < 0.14.0 import typing from dataclasses_avroschema import SchemaGenerator , types class User : \"An User\" name : str age : int pets : typing . List [ str ] accounts : typing . Dict [ str , int ] favorite_colors : types . Enum = types . Enum ([ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]) country : str = \"Argentina\" address : str = None SchemaGenerator ( User ) . avro_schema () # New versions from dataclasses_avroschema import AvroModel , types class User ( AvroModel ): \"An User\" name : str age : int pets : typing . List [ str ] accounts : typing . Dict [ str , int ] favorite_colors : types . Enum = types . Enum ([ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]) country : str = \"Argentina\" address : str = None User . avro_schema () Another changes introduced was the way that extra avro attributes are represented, like namespace , aliases and whether to include avro documentation : class User : \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 def extra_avro_attributes () -> typing . Dict [ str , typing . Any ]: return { \"namespace\" : \"test.com.ar/user/v1\" , \"aliases\" : [ \"User\" , \"My favorite User\" ] } SchemaGenerator ( User , include_schema_doc = False ) . avro_schema () # Now is perform using a Meta class class User ( AvroModel ): \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 class Meta : schema_doc = False namespace = \"test.com.ar/user/v1\" aliases = [ \"User\" , \"My favorite User\" ]","title":"Migration Guide"},{"location":"migration_guide/#migration-from-previous-versions-to-0140","text":"Now all the dataclasses should inheritance from AvroModel and not use anymore the SchemaGenerator : # Versions < 0.14.0 import typing from dataclasses_avroschema import SchemaGenerator , types class User : \"An User\" name : str age : int pets : typing . List [ str ] accounts : typing . Dict [ str , int ] favorite_colors : types . Enum = types . Enum ([ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]) country : str = \"Argentina\" address : str = None SchemaGenerator ( User ) . avro_schema () # New versions from dataclasses_avroschema import AvroModel , types class User ( AvroModel ): \"An User\" name : str age : int pets : typing . List [ str ] accounts : typing . Dict [ str , int ] favorite_colors : types . Enum = types . Enum ([ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]) country : str = \"Argentina\" address : str = None User . avro_schema () Another changes introduced was the way that extra avro attributes are represented, like namespace , aliases and whether to include avro documentation : class User : \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 def extra_avro_attributes () -> typing . Dict [ str , typing . Any ]: return { \"namespace\" : \"test.com.ar/user/v1\" , \"aliases\" : [ \"User\" , \"My favorite User\" ] } SchemaGenerator ( User , include_schema_doc = False ) . avro_schema () # Now is perform using a Meta class class User ( AvroModel ): \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 class Meta : schema_doc = False namespace = \"test.com.ar/user/v1\" aliases = [ \"User\" , \"My favorite User\" ]","title":"Migration from previous versions to 0.14.0"},{"location":"primitive_types/","text":"The following list represent the avro primitive types mapped to python types: Avro Type Python Type string str int int boolean bool float float null None bytes bytes Example: from dataclasses_avroschema import AvroModel class User ( AvroModel ): \"An User\" name : str age : int is_student : bool money_available : float encoded : bytes User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"is_student\" , \"type\" : \"boolean\" }, { \"name\" : \"money_available\" , \"type\" : \"float\" }, { \"name\" : \"encoded\" , \"type\" : \"bytes\" } ], \"doc\" : \"An User\" } ' Example with defaults: from dataclasses_avroschema import AvroModel class User ( AvroModel ): \"An User\" name : str = None age : int = None is_student : bool = None money_available : float = None encoded : bytes = None User . avro_schema () # We can see the use of null in the schema generated: '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : null }, { \"name\" : \"age\" , \"type\" : [ \"null\" , \"int\" ], \"default\" : null }, { \"name\" : \"is_student\" , \"type\" : [ \"null\" , \"boolean\" ], \"default\" : null }, { \"name\" : \"money_available\" , \"type\" : [ \"null\" , \"float\" ], \"default\" : null }, { \"name\" : \"encoded\" , \"type\" : [ \"null\" , \"bytes\" ], \"default\" : null } ], \"doc\" : \"An User\" } ' # Or with null as a second type argument: class User ( AvroModel ): \"An User\" name : str = 'Juan' age : int = 20 is_student : bool = True money_available : float = 100.2 encoded : bytes = b \"hi\" User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" , \"default\" : \"Juan\" }, { \"name\" : \"age\" , \"type\" : \"int\" , \"default\" : 20 }, { \"name\" : \"is_student\" , \"type\" : \"boolean\" , \"default\" : true }, { \"name\" : \"money_available\" , \"type\" : \"float\" , \"default\" : 100.2 }, { \"name\" : \"encoded\" , \"type\" : \"bytes\" , \"default\" : \"hi\" } ], \"doc\" : \"An User\" } '","title":"Primitive Types"},{"location":"redis_examples/","text":"Minimal redis example using redis streams with walrus driver. from dataclasses import dataclass import random from time import sleep from walrus import Database # A subclass of the redis-py Redis client. from dataclasses_avroschema import AvroModel , types @dataclass class UserModel ( AvroModel ): \"An User\" name : str age : int favorite_colors : types . Enum = types . Enum ([ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], default = \"BLUE\" ) country : str = \"Argentina\" address : str = None testing : bool = False class Meta : namespace = \"User.v1\" aliases = [ \"user-v1\" , \"super user\" ] def consume ( consumer_group ): # read new messages in the stream while True : result = consumer_group . my_stream . read ( count = 1 , block = 1000 ) # Each record has the followinf format # [(b'1598545738231-0', {b'message': b'\\x06KimT\\x00\\x12Argentina\\x00\\x00'})] if result : message_id , message_content = result [ 0 ] if message_id : value = message_content [ b 'message' ] print ( f \"Processing message { message_id } with value { value } \" ) user = UserModel . deserialize ( value ) print ( user ) def produce ( consumer_group ): for i in range ( 10 ): # create an instance of User v1 user = UserModel ( name = random . choice ([ \"Juan\" , \"Peter\" , \"Michael\" , \"Moby\" , \"Kim\" ,]), age = random . randint ( 1 , 50 ) ) msgid = consumer_group . my_stream . add ({ \"message\" : user . serialize ()}) print ( f \"Producing message { msgid } \" ) print ( \"Producer finished....\" ) print ( \"#\" * 80 ) sleep ( 2 ) if __name__ == \"__main__\" : db = Database () stream_name = 'my-stream' db . Stream ( stream_name ) # Create a new stream instance # create the consumer group consumer_group = db . consumer_group ( 'my-consumer-group-1' , [ stream_name ]) consumer_group . create () # Create the consumer group. consumer_group . set_id ( '$' ) produce ( consumer_group ) consume ( consumer_group )","title":"Redis examples"},{"location":"schema_relationships/","text":"Schema Relationships OneToOne An User has one Address example: from dataclasses_avroschema import AvroModel class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"An User with Address\" name : str age : int address : Address User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"address\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"int\" } ], \"doc\" : \"An Address\" } } ], \"doc\" : \"An User with Address\" } ' OneToOne Recursive Schema Relationship An User with only one friend :-( : import typing from dataclasses_avroschema import AvroModel class User ( AvroModel ): \"User with self reference as friend\" name : str age : int friend : typing . Type [ \"User\" ] = None User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"friend\" , \"type\" : [ \"null\" , \"User\" ], \"default\" : null } ], \"doc\" : \"User with self reference as friend\" } ' OneToMany Schema Relationship An User has multiple Address example: import typing from dataclasses_avroschema import AvroModel class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"addresses\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"int\" } ], \"doc\" : \"An Address\" }, \"name\" : \"address\" } } ], \"doc\" : \"User with multiple Address\" } ' or OneToMany using a Map: import typing from dataclasses_avroschema import AvroModel class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . Dict [ str , Address ] User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"addresses\" , \"type\" : { \"type\" : \"map\" , \"values\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"int\" } ], \"doc\" : \"An Address\" }, \"name\" : \"address\" } } ], \"doc\" : \"User with multiple Address\" } ' OneToMany Recursive Schema Relationship An User with multiple friends :-) : import typing from dataclasses_avroschema import AvroModel # Using a List (Avro Array) class User ( AvroModel ): \"User with self reference as friends\" name : str age : int friends : typing . List [ typing . Type [ \"User\" ]] = None User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"friends\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"User\" , \"name\" : \"friend\" }, \"default\" : [] } ], \"doc\" : \"User with self reference as friends\" } ' # Using a Dict (Avro Map) class User ( AvroModel ): \"User with self reference as friends\" name : str age : int friends : typing . Dict [ str , typing . Type [ \"User\" ]] = None User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"friends\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"User\" , \"name\" : \"friend\" }, \"default\" : {} } ], \"doc\" : \"User with self reference as friends\" } '","title":"Schema Relationships"},{"location":"schema_relationships/#schema-relationships","text":"","title":"Schema Relationships"},{"location":"schema_relationships/#onetoone","text":"An User has one Address example: from dataclasses_avroschema import AvroModel class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"An User with Address\" name : str age : int address : Address User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"address\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"int\" } ], \"doc\" : \"An Address\" } } ], \"doc\" : \"An User with Address\" } '","title":"OneToOne"},{"location":"schema_relationships/#onetoone-recursive-schema-relationship","text":"An User with only one friend :-( : import typing from dataclasses_avroschema import AvroModel class User ( AvroModel ): \"User with self reference as friend\" name : str age : int friend : typing . Type [ \"User\" ] = None User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"friend\" , \"type\" : [ \"null\" , \"User\" ], \"default\" : null } ], \"doc\" : \"User with self reference as friend\" } '","title":"OneToOne Recursive Schema Relationship"},{"location":"schema_relationships/#onetomany-schema-relationship","text":"An User has multiple Address example: import typing from dataclasses_avroschema import AvroModel class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"addresses\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"int\" } ], \"doc\" : \"An Address\" }, \"name\" : \"address\" } } ], \"doc\" : \"User with multiple Address\" } ' or OneToMany using a Map: import typing from dataclasses_avroschema import AvroModel class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . Dict [ str , Address ] User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"addresses\" , \"type\" : { \"type\" : \"map\" , \"values\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"int\" } ], \"doc\" : \"An Address\" }, \"name\" : \"address\" } } ], \"doc\" : \"User with multiple Address\" } '","title":"OneToMany Schema Relationship"},{"location":"schema_relationships/#onetomany-recursive-schema-relationship","text":"An User with multiple friends :-) : import typing from dataclasses_avroschema import AvroModel # Using a List (Avro Array) class User ( AvroModel ): \"User with self reference as friends\" name : str age : int friends : typing . List [ typing . Type [ \"User\" ]] = None User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"friends\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"User\" , \"name\" : \"friend\" }, \"default\" : [] } ], \"doc\" : \"User with self reference as friends\" } ' # Using a Dict (Avro Map) class User ( AvroModel ): \"User with self reference as friends\" name : str age : int friends : typing . Dict [ str , typing . Type [ \"User\" ]] = None User . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"friends\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"User\" , \"name\" : \"friend\" }, \"default\" : {} } ], \"doc\" : \"User with self reference as friends\" } '","title":"OneToMany Recursive Schema Relationship"},{"location":"serialization/","text":"Is possible to serialize/deserialize with the correspondent avro schema generated and the dataclass. In both cases we can do it with avro or avro-json . Serialization For serialization is neccesary to use python class/dataclasses instance: from dataclasses import dataclass import typing from dataclasses_avroschema import AvroModel @dataclass class Address ( AvroModel ): \"An Address\" street : str street_number : int @dataclass class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] address_data = { \"street\" : \"test\" , \"street_number\" : 10 , } # create an Address instance address = Address ( ** address_data ) data_user = { \"name\" : \"john\" , \"age\" : 20 , \"addresses\" : [ address ], } # create an User instance user = User ( ** data_user ) user . serialize () # >>> b\"\\x08john(\\x02\\x08test\\x14\\x00\" user . serialize ( serialization_type = \"avro-json\" ) # >>> b'{\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]}' user . to_json () # python dict >>> {'name': 'john', 'age': 20, 'addresses': [{'street': 'test', 'street_number': 10}]} Deserialization Deserialization could take place with an instance dataclass or the dataclass itself. Can return the dict representation or a new class instance. import typing from dataclasses_avroschema import AvroModel class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] avro_binary = b \" \\x08 john( \\x02\\x08 test \\x14\\x00 \" avro_json_binary = b '{\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]}' # return a new class instance!! User . deserialize ( avro_binary ) # >>>> User(name='john', age=20, addresses=[Address(street='test', street_number=10)]) # return a python dict User . deserialize ( avro_binary , create_instance = False ) # >>> {\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]} # return a new class instance!! User . deserialize ( avro_json_binary , serialization_type = \"avro-json\" ) # >>>> User(name='john', age=20, addresses=[Address(street='test', street_number=10)]) # return a python dict User . deserialize ( avro_json_binary , serialization_type = \"avro-json\" , create_instance = False ) # >>> {\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]} Custom Serialization The serialization/deserialization process is built over fastavro . If you want to use another library or a different process, you can override the base AvroModel : from dataclasses_avroschema import AvroModel class MyAvroModel ( AvroModel ): ... def serialize ( self , serialization_type : str = AVRO ) -> bytes : # Get the schema as a python dict schema = self . avro_schema_to_python () # instance as python dict data = self . asdict () # call your custom serialization withe the avro schema and the data return custom_serialization ( schema , datam serialization_type = serialization_type ) @classmethod def deserialize ( cls , data : bytes , serialization_type : str = AVRO , create_instance : bool = True ) -> typing . Union [ typing . Dict , \"AvroModel\" ]: # Get the schema as a python dict schema = cls . avro_schema_to_python () # get the python dict with the schema and the data (bytes) payload = custom_deserialize ( data , schema , serialization_type = serialization_type ) if create_instance : return from_dict ( data_class = cls , data = payload , config = Config ( check_types = False )) return payload # and then inherits from your custom AvroModel class Address ( MyAvroModel ): \"An Address\" street : str street_number : int","title":"Serialization"},{"location":"serialization/#serialization","text":"For serialization is neccesary to use python class/dataclasses instance: from dataclasses import dataclass import typing from dataclasses_avroschema import AvroModel @dataclass class Address ( AvroModel ): \"An Address\" street : str street_number : int @dataclass class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] address_data = { \"street\" : \"test\" , \"street_number\" : 10 , } # create an Address instance address = Address ( ** address_data ) data_user = { \"name\" : \"john\" , \"age\" : 20 , \"addresses\" : [ address ], } # create an User instance user = User ( ** data_user ) user . serialize () # >>> b\"\\x08john(\\x02\\x08test\\x14\\x00\" user . serialize ( serialization_type = \"avro-json\" ) # >>> b'{\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]}' user . to_json () # python dict >>> {'name': 'john', 'age': 20, 'addresses': [{'street': 'test', 'street_number': 10}]}","title":"Serialization"},{"location":"serialization/#deserialization","text":"Deserialization could take place with an instance dataclass or the dataclass itself. Can return the dict representation or a new class instance. import typing from dataclasses_avroschema import AvroModel class Address ( AvroModel ): \"An Address\" street : str street_number : int class User ( AvroModel ): \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] avro_binary = b \" \\x08 john( \\x02\\x08 test \\x14\\x00 \" avro_json_binary = b '{\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]}' # return a new class instance!! User . deserialize ( avro_binary ) # >>>> User(name='john', age=20, addresses=[Address(street='test', street_number=10)]) # return a python dict User . deserialize ( avro_binary , create_instance = False ) # >>> {\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]} # return a new class instance!! User . deserialize ( avro_json_binary , serialization_type = \"avro-json\" ) # >>>> User(name='john', age=20, addresses=[Address(street='test', street_number=10)]) # return a python dict User . deserialize ( avro_json_binary , serialization_type = \"avro-json\" , create_instance = False ) # >>> {\"name\": \"john\", \"age\": 20, \"addresses\": [{\"street\": \"test\", \"street_number\": 10}]}","title":"Deserialization"},{"location":"serialization/#custom-serialization","text":"The serialization/deserialization process is built over fastavro . If you want to use another library or a different process, you can override the base AvroModel : from dataclasses_avroschema import AvroModel class MyAvroModel ( AvroModel ): ... def serialize ( self , serialization_type : str = AVRO ) -> bytes : # Get the schema as a python dict schema = self . avro_schema_to_python () # instance as python dict data = self . asdict () # call your custom serialization withe the avro schema and the data return custom_serialization ( schema , datam serialization_type = serialization_type ) @classmethod def deserialize ( cls , data : bytes , serialization_type : str = AVRO , create_instance : bool = True ) -> typing . Union [ typing . Dict , \"AvroModel\" ]: # Get the schema as a python dict schema = cls . avro_schema_to_python () # get the python dict with the schema and the data (bytes) payload = custom_deserialize ( data , schema , serialization_type = serialization_type ) if create_instance : return from_dict ( data_class = cls , data = payload , config = Config ( check_types = False )) return payload # and then inherits from your custom AvroModel class Address ( MyAvroModel ): \"An Address\" street : str street_number : int","title":"Custom Serialization"}]}