{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dataclasses Avro Schema Generator Generate Avro Schemas from a Python class Requirements: python 3.7+ Installation pip install dataclasses-avroschema Usage: from dataclasses_avroschema.schema_generator import SchemaGenerator class User : \"An User\" name : str age : int pets : typing . List [ str ] accounts : typing . Dict [ str , int ] favorite_colors : typing . Tuple [ str ] = ( \"BLUE\" , \"YELLOW\" , \"GREEN\" ) country : str = \"Argentina\" address : str = None SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"pets\" , \"type\" : \"array\" , \"items\" : \"string\" }, { \"name\" : \"accounts\" , \"type\" : \"map\" , \"values\" : \"int\" }, { \"name\" : \"favorite_colors\" , \"type\" : \"enum\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]}, { \"name\" : \"country\" , \"type\" : [ \"string\" , \"null\" ], \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : \"null\" } ] } ' Features: [X] Primitive types: int, long, float, boolean, string and null support [X] Complex types: enum, array, map, unions and records support [x] Logical Types: date, time, datetime, uuid support [X] Schema relations (oneToOne, oneToMany) [X] Recursive Schemas","title":"Introduction"},{"location":"#dataclasses-avro-schema-generator","text":"Generate Avro Schemas from a Python class","title":"Dataclasses Avro Schema Generator"},{"location":"#requirements","text":"python 3.7+","title":"Requirements:"},{"location":"#installation","text":"pip install dataclasses-avroschema","title":"Installation"},{"location":"#usage","text":"from dataclasses_avroschema.schema_generator import SchemaGenerator class User : \"An User\" name : str age : int pets : typing . List [ str ] accounts : typing . Dict [ str , int ] favorite_colors : typing . Tuple [ str ] = ( \"BLUE\" , \"YELLOW\" , \"GREEN\" ) country : str = \"Argentina\" address : str = None SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"doc\" : \"An User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"pets\" , \"type\" : \"array\" , \"items\" : \"string\" }, { \"name\" : \"accounts\" , \"type\" : \"map\" , \"values\" : \"int\" }, { \"name\" : \"favorite_colors\" , \"type\" : \"enum\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ]}, { \"name\" : \"country\" , \"type\" : [ \"string\" , \"null\" ], \"default\" : \"Argentina\" }, { \"name\" : \"address\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : \"null\" } ] } '","title":"Usage:"},{"location":"#features","text":"[X] Primitive types: int, long, float, boolean, string and null support [X] Complex types: enum, array, map, unions and records support [x] Logical Types: date, time, datetime, uuid support [X] Schema relations (oneToOne, oneToMany) [X] Recursive Schemas","title":"Features:"},{"location":"avro_schema/","text":"Avro Schemas and Python Class What is Apache Avro? Avro is a row-oriented remote procedure call and data serialization framework developed within Apache's Hadoop project. It uses JSON for defining data types and protocols, and serializes data in a compact binary format. Avro uses a schema to structure the data that is being encoded. It has two different types of schema languages; one for human editing (Avro IDL) and another which is more machine-readable based on (JSON) Goal Our goal is to come up with an avro schema from Python classes . We can think a avro Record as an analogous to a python class , but first, let's explaine what a record is. Records Records are one of the Complex Types in avro. It use the type name record and support three attributes. name: a JSON string providing the name of the record (required). namespace: a JSON string that qualifies the name; doc: a JSON string providing documentation to the user of this schema (optional). aliases: a JSON array of strings, providing alternate names for this record (optional). fields: a JSON array, listing fields (required). Each field is a JSON object with the following attributes: name: a JSON string providing the name of the field (required), and doc: a JSON string describing this field for users (optional). type: A JSON object defining a schema, or a JSON string naming a record definition (required). default: A default value for this field, used when reading instances that lack this field (optional). Permitted values depend on the field's schema type, according to the table below. Default values for union fields correspond to the first schema in the union. Default values for bytes and fixed fields are JSON strings, where Unicode code points 0-255 are mapped to unsigned 8-bit byte values 0-255. order: specifies how this field impacts sort ordering of this record (optional). Valid values are \"ascending\" (the default), \"descending\", or \"ignore\". For more details on how this is used, see the the sort order section below. aliases: a JSON array of strings, providing alternate names for this field (optional). For example, a User may be defined with: { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" }, { \"name\" : \"money\" , \"type\" : \"float\" } ] } From a Python class to the Avo Schema Image that you have to define the previous User schema but you do not know avro, you know python: from dataclasses_avroschema.schema_generator import SchemaGenerator class User : name : str age : int has_pets : bool money : float SchemaGenerator ( User ) . avro_schema () { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" }, { \"name\" : \"money\" , \"type\" : \"float\" } ], \"doc\" : \"User(name: str, age: int, has_pets: bool, money: float)\" } ' and that is it!! Each python field is related with a avro type. You can find the field relationships here :","title":"Avro Schema and Python Classes"},{"location":"avro_schema/#avro-schemas-and-python-class","text":"","title":"Avro Schemas and Python Class"},{"location":"avro_schema/#what-is-apache-avro","text":"Avro is a row-oriented remote procedure call and data serialization framework developed within Apache's Hadoop project. It uses JSON for defining data types and protocols, and serializes data in a compact binary format. Avro uses a schema to structure the data that is being encoded. It has two different types of schema languages; one for human editing (Avro IDL) and another which is more machine-readable based on (JSON)","title":"What is Apache Avro?"},{"location":"avro_schema/#goal","text":"Our goal is to come up with an avro schema from Python classes . We can think a avro Record as an analogous to a python class , but first, let's explaine what a record is.","title":"Goal"},{"location":"avro_schema/#records","text":"Records are one of the Complex Types in avro. It use the type name record and support three attributes. name: a JSON string providing the name of the record (required). namespace: a JSON string that qualifies the name; doc: a JSON string providing documentation to the user of this schema (optional). aliases: a JSON array of strings, providing alternate names for this record (optional). fields: a JSON array, listing fields (required). Each field is a JSON object with the following attributes: name: a JSON string providing the name of the field (required), and doc: a JSON string describing this field for users (optional). type: A JSON object defining a schema, or a JSON string naming a record definition (required). default: A default value for this field, used when reading instances that lack this field (optional). Permitted values depend on the field's schema type, according to the table below. Default values for union fields correspond to the first schema in the union. Default values for bytes and fixed fields are JSON strings, where Unicode code points 0-255 are mapped to unsigned 8-bit byte values 0-255. order: specifies how this field impacts sort ordering of this record (optional). Valid values are \"ascending\" (the default), \"descending\", or \"ignore\". For more details on how this is used, see the the sort order section below. aliases: a JSON array of strings, providing alternate names for this field (optional). For example, a User may be defined with: { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" }, { \"name\" : \"money\" , \"type\" : \"float\" } ] }","title":"Records"},{"location":"avro_schema/#from-a-python-class-to-the-avo-schema","text":"Image that you have to define the previous User schema but you do not know avro, you know python: from dataclasses_avroschema.schema_generator import SchemaGenerator class User : name : str age : int has_pets : bool money : float SchemaGenerator ( User ) . avro_schema () { \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : \"boolean\" }, { \"name\" : \"money\" , \"type\" : \"float\" } ], \"doc\" : \"User(name: str, age: int, has_pets: bool, money: float)\" } ' and that is it!! Each python field is related with a avro type. You can find the field relationships here :","title":"From a Python class to the Avo Schema"},{"location":"complex_types/","text":"Complex Types The following list represent the avro complext types mapped to python types: Avro Type Python Type enums tuple arrays list maps dict unions typing.Union records Python Class Enums Example: import typing from dataclasses_avroschema.schema_generator import SchemaGenerator class User : \"An User\" favorite_colors : typing . Tuple [ str ] = ( \"BLUE\" , \"YELLOW\" , \"GREEN\" ) SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"favorite_colors\" , \"type\" : { \"type\" : \"enum\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], \"name\" : \"favorite_color\" } } ], \"doc\" : \"An User\" } ' Arrays Example: import typing import dataclasses from dataclasses_avroschema.schema_generator import SchemaGenerator class UserAdvance : \"User advanced\" pets : typing . List [ str ] cars : typing . List [ str ] = None favourites_numbers : typing . List [ int ] = dataclasses . field ( default_factory = lambda : [ 7 , 13 ]) SchemaGenerator ( UserAdvance ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"pet\" } }, { \"name\" : \"cars\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"car\" }, \"default\" : [] }, { \"name\" : \"favourites_numbers\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"int\" , \"name\" : \"favourites_number\" }, \"default\" : [ 7 , 13 ] } ], \"doc\" : \"User advanced\" } ' Maps Example: import typing import dataclasses from dataclasses_avroschema.schema_generator import SchemaGenerator class UserAdvance : \"User advanced\" accounts_money : typing . Dict [ str , float ] cars_brand_total : typing . Dict [ str , int ] = None family_ages : typing . Dict [ str , int ] = dataclasses . field ( default_factory = lambda : { \"father\" : 50 }) SchemaGenerator ( UserAdvance ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"accounts_money\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"float\" , \"name\" : \"accounts_money\" } }, { \"name\" : \"cars_brand_total\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"int\" , \"name\" : \"cars_brand_total\" }, \"default\" : {} }, { \"name\" : \"family_ages\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"int\" , \"name\" : \"family_age\" }, \"default\" : { \"father\" : 50 } } ], \"doc\" : \"User advanced\" } ' Records Mapped as a Python class There are some special avro attributes like aliases , namespace and doc (both not required) that can be specified in a record type. The doc attribute can be set via the docstring class. The aliases and namespaces must be set using the extra_avro_attributes static method. from dataclasses_avroschema.schema_generator import SchemaGenerator class User : \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 def extra_avro_attributes () -> typing . Dict [ str , typing . Any ]: return { \"namespace\" : \"test.com.ar/user/v1\" , \"aliases\" : [ \"User\" , \"My favorite User\" ] } SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : [ \"boolean\" , \"null\" ], \"default\" : false }, { \"name\" : \"money\" , \"type\" : [ \"float\" , \"null\" ], \"default\" : 100.3 } ], \"doc\" : \"My User Class\" , \"namespace\" : \"test.com.ar/user/v1\" , \"aliases\" : [ \"User\" , \"My favorite User\" ] } ' Unions import typing import dataclasses from dataclasses_avroschema.schema_generator import SchemaGenerator class Bus : \"A Bus\" engine_name : str class Car : \"A Car\" engine_name : str class UnionSchema : \"Some Unions\" lake_trip : typing . Union [ Bus , Car ] river_trip : typing . Union [ Bus , Car ] = None mountain_trip : typing . Union [ Bus , Car ] = dataclasses . field ( default_factory = lambda : { \"engine_name\" : \"honda\" }) '{ \"type\" : \"record\" , \"name\" : \"UnionSchema\" , \"fields\" : [ { \"name\" : \"lake_trip\" , \"type\" : [ { \"type\" : \"record\" , \"name\" : \"Bus\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Bus\" }, { \"type\" : \"record\" , \"name\" : \"Car\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Car\" } ] }, { \"name\" : \"river_trip\" , \"type\" : [ \"null\" , { \"type\" : \"record\" , \"name\" : \"Bus\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Bus\" }, { \"type\" : \"record\" , \"name\" : \"Car\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Car\" } ], \"default\" : \"null\" }, { \"name\" : \"mountain_trip\" , \"type\" : [ { \"type\" : \"record\" , \"name\" : \"Bus\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Bus\" }, { \"type\" : \"record\" , \"name\" : \"Car\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Car\" } ], \"default\" : { \"engine_name\" : \"honda\" } } ], \"doc\" : \"Some Unions\" } '","title":"Complex Types"},{"location":"complex_types/#complex-types","text":"The following list represent the avro complext types mapped to python types: Avro Type Python Type enums tuple arrays list maps dict unions typing.Union records Python Class","title":"Complex Types"},{"location":"complex_types/#enums","text":"Example: import typing from dataclasses_avroschema.schema_generator import SchemaGenerator class User : \"An User\" favorite_colors : typing . Tuple [ str ] = ( \"BLUE\" , \"YELLOW\" , \"GREEN\" ) SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"favorite_colors\" , \"type\" : { \"type\" : \"enum\" , \"symbols\" : [ \"BLUE\" , \"YELLOW\" , \"GREEN\" ], \"name\" : \"favorite_color\" } } ], \"doc\" : \"An User\" } '","title":"Enums"},{"location":"complex_types/#arrays","text":"Example: import typing import dataclasses from dataclasses_avroschema.schema_generator import SchemaGenerator class UserAdvance : \"User advanced\" pets : typing . List [ str ] cars : typing . List [ str ] = None favourites_numbers : typing . List [ int ] = dataclasses . field ( default_factory = lambda : [ 7 , 13 ]) SchemaGenerator ( UserAdvance ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"pets\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"pet\" } }, { \"name\" : \"cars\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" , \"name\" : \"car\" }, \"default\" : [] }, { \"name\" : \"favourites_numbers\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"int\" , \"name\" : \"favourites_number\" }, \"default\" : [ 7 , 13 ] } ], \"doc\" : \"User advanced\" } '","title":"Arrays"},{"location":"complex_types/#maps","text":"Example: import typing import dataclasses from dataclasses_avroschema.schema_generator import SchemaGenerator class UserAdvance : \"User advanced\" accounts_money : typing . Dict [ str , float ] cars_brand_total : typing . Dict [ str , int ] = None family_ages : typing . Dict [ str , int ] = dataclasses . field ( default_factory = lambda : { \"father\" : 50 }) SchemaGenerator ( UserAdvance ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UserAdvance\" , \"fields\" : [ { \"name\" : \"accounts_money\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"float\" , \"name\" : \"accounts_money\" } }, { \"name\" : \"cars_brand_total\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"int\" , \"name\" : \"cars_brand_total\" }, \"default\" : {} }, { \"name\" : \"family_ages\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"int\" , \"name\" : \"family_age\" }, \"default\" : { \"father\" : 50 } } ], \"doc\" : \"User advanced\" } '","title":"Maps"},{"location":"complex_types/#records","text":"Mapped as a Python class There are some special avro attributes like aliases , namespace and doc (both not required) that can be specified in a record type. The doc attribute can be set via the docstring class. The aliases and namespaces must be set using the extra_avro_attributes static method. from dataclasses_avroschema.schema_generator import SchemaGenerator class User : \"My User Class\" name : str age : int has_pets : bool = False money : float = 100.3 def extra_avro_attributes () -> typing . Dict [ str , typing . Any ]: return { \"namespace\" : \"test.com.ar/user/v1\" , \"aliases\" : [ \"User\" , \"My favorite User\" ] } SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"has_pets\" , \"type\" : [ \"boolean\" , \"null\" ], \"default\" : false }, { \"name\" : \"money\" , \"type\" : [ \"float\" , \"null\" ], \"default\" : 100.3 } ], \"doc\" : \"My User Class\" , \"namespace\" : \"test.com.ar/user/v1\" , \"aliases\" : [ \"User\" , \"My favorite User\" ] } '","title":"Records"},{"location":"complex_types/#unions","text":"import typing import dataclasses from dataclasses_avroschema.schema_generator import SchemaGenerator class Bus : \"A Bus\" engine_name : str class Car : \"A Car\" engine_name : str class UnionSchema : \"Some Unions\" lake_trip : typing . Union [ Bus , Car ] river_trip : typing . Union [ Bus , Car ] = None mountain_trip : typing . Union [ Bus , Car ] = dataclasses . field ( default_factory = lambda : { \"engine_name\" : \"honda\" }) '{ \"type\" : \"record\" , \"name\" : \"UnionSchema\" , \"fields\" : [ { \"name\" : \"lake_trip\" , \"type\" : [ { \"type\" : \"record\" , \"name\" : \"Bus\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Bus\" }, { \"type\" : \"record\" , \"name\" : \"Car\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Car\" } ] }, { \"name\" : \"river_trip\" , \"type\" : [ \"null\" , { \"type\" : \"record\" , \"name\" : \"Bus\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Bus\" }, { \"type\" : \"record\" , \"name\" : \"Car\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Car\" } ], \"default\" : \"null\" }, { \"name\" : \"mountain_trip\" , \"type\" : [ { \"type\" : \"record\" , \"name\" : \"Bus\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Bus\" }, { \"type\" : \"record\" , \"name\" : \"Car\" , \"fields\" : [ { \"name\" : \"engine_name\" , \"type\" : \"string\" } ], \"doc\" : \"A Car\" } ], \"default\" : { \"engine_name\" : \"honda\" } } ], \"doc\" : \"Some Unions\" } '","title":"Unions"},{"location":"fields_specification/","text":"Avro Fields and Python Fields Apache Avro has Primitive Types , Complex Types and Logical Types , so we need to match these types with python types. Primitive Types and python representation The set of primitive type names is: null: no value boolean: a binary value int: 32-bit signed integer long: 64-bit signed integer float: single precision (32-bit) IEEE 754 floating-point number double: double precision (64-bit) IEEE 754 floating-point number bytes: sequence of 8-bit unsigned bytes string: unicode character sequence So, the previous types can be matched to: Avro Type Python Type string str int int boolean bool float float null None bytes wip Complex Types Avro supports six kinds of complex types: enums, arrays, maps, unions, fixed and records. Avro Type Python Type enums tuple arrays list maps dict unions typing.Union records Python Class Enums: Use the type name \"enum\" and support the following attributes: name: a JSON string providing the name of the enum (required). namespace: a JSON string that qualifies the name; aliases: a JSON array of strings, providing alternate names for this enum (optional). doc: a JSON string providing documentation to the user of this schema (optional). symbols: a JSON array, listing symbols, as JSON strings (required). All symbols in an enum must be unique; duplicates are prohibited. Every symbol must match the regular expression [A-Za-z_][A-Za-z0-9_]* (the same requirement as for names). When we want to define a enum type we should specify a default value because we need to define the symbols In future version we will have a custom enum type to avoid this Arrays: Use the type name \"array\" and support the following attribute: name: a JSON string providing the name of the enum (required). items: the schema of the array's items. Maps: Use the type name \"map\". Map keys are assumed to be string. Support the following attribute: name: a JSON string providing the name of the enum (required). values: the schema of the map's values. Unions: Unions are represented using JSON arrays. For example, [\"null\", \"string\"] declares a schema which may be either a null or string. Records: Records use the type name record and will represent the Schema . Logical Types A logical type is an Avro primitive or complex type with extra attributes to represent a derived type. The attribute logicalType must always be present for a logical type, and is a string with the name of one of the logical types listed later in this section. Other attributes may be defined for particular logical types. A logical type is always serialized using its underlying Avro type so that values are encoded in exactly the same way as the equivalent Avro type that does not have a logicalType attribute. Language implementations may choose to represent logical types with an appropriate native type, although this is not required. Language implementations must ignore unknown logical types when reading, and should use the underlying Avro type. If a logical type is invalid, for example a decimal with scale greater than its precision, then implementations should ignore the logical type and use the underlying Avro type. Date: The date logical type represents a date within the calendar, with no reference to a particular time zone or time of day. A date logical type annotates an Avro int, where the int stores the number of days from the unix epoch, 1 January 1970 (ISO calendar). Time (millisecond precision): The time-millis logical type represents a time of day, with no reference to a particular calendar, time zone or date, with a precision of one millisecond. A time-millis logical type annotates an Avro int, where the int stores the number of milliseconds after midnight, 00:00:00.000. Timestamp (millisecond precision): The timestamp-millis logical type represents an instant on the global timeline, independent of a particular time zone or calendar, with a precision of one millisecond. A timestamp-millis logical type annotates an Avro long, where the long stores the number of milliseconds from the unix epoch, 1 January 1970 00:00:00.000 UTC. UUID: Represents a uuid as a string Avro Type Logical Type Python Type int date datetime.date int time-millis datetime.time long timestamp-millis datetime.datetime string uuid uuid.uuid4 Avro Field and Python Types Summary Python Type Avro Type Logical Type str string do not apply int int do not apply bool boolean do not apply float float do not apply None null do not apply bytes bytes do not apply tuple enum do not apply list array do not apply dict map do not apply typing.Union union do not apply Pythin classs record do not apply datetime.date int date datetime.time int time-millis datetime.datetim long timestamp-millis uuid.uuid4 string uuid","title":"Fields Specification"},{"location":"fields_specification/#avro-fields-and-python-fields","text":"Apache Avro has Primitive Types , Complex Types and Logical Types , so we need to match these types with python types.","title":"Avro Fields and Python Fields"},{"location":"fields_specification/#primitive-types-and-python-representation","text":"The set of primitive type names is: null: no value boolean: a binary value int: 32-bit signed integer long: 64-bit signed integer float: single precision (32-bit) IEEE 754 floating-point number double: double precision (64-bit) IEEE 754 floating-point number bytes: sequence of 8-bit unsigned bytes string: unicode character sequence So, the previous types can be matched to: Avro Type Python Type string str int int boolean bool float float null None bytes wip","title":"Primitive Types and python representation"},{"location":"fields_specification/#complex-types","text":"Avro supports six kinds of complex types: enums, arrays, maps, unions, fixed and records. Avro Type Python Type enums tuple arrays list maps dict unions typing.Union records Python Class Enums: Use the type name \"enum\" and support the following attributes: name: a JSON string providing the name of the enum (required). namespace: a JSON string that qualifies the name; aliases: a JSON array of strings, providing alternate names for this enum (optional). doc: a JSON string providing documentation to the user of this schema (optional). symbols: a JSON array, listing symbols, as JSON strings (required). All symbols in an enum must be unique; duplicates are prohibited. Every symbol must match the regular expression [A-Za-z_][A-Za-z0-9_]* (the same requirement as for names). When we want to define a enum type we should specify a default value because we need to define the symbols In future version we will have a custom enum type to avoid this Arrays: Use the type name \"array\" and support the following attribute: name: a JSON string providing the name of the enum (required). items: the schema of the array's items. Maps: Use the type name \"map\". Map keys are assumed to be string. Support the following attribute: name: a JSON string providing the name of the enum (required). values: the schema of the map's values. Unions: Unions are represented using JSON arrays. For example, [\"null\", \"string\"] declares a schema which may be either a null or string. Records: Records use the type name record and will represent the Schema .","title":"Complex Types"},{"location":"fields_specification/#logical-types","text":"A logical type is an Avro primitive or complex type with extra attributes to represent a derived type. The attribute logicalType must always be present for a logical type, and is a string with the name of one of the logical types listed later in this section. Other attributes may be defined for particular logical types. A logical type is always serialized using its underlying Avro type so that values are encoded in exactly the same way as the equivalent Avro type that does not have a logicalType attribute. Language implementations may choose to represent logical types with an appropriate native type, although this is not required. Language implementations must ignore unknown logical types when reading, and should use the underlying Avro type. If a logical type is invalid, for example a decimal with scale greater than its precision, then implementations should ignore the logical type and use the underlying Avro type. Date: The date logical type represents a date within the calendar, with no reference to a particular time zone or time of day. A date logical type annotates an Avro int, where the int stores the number of days from the unix epoch, 1 January 1970 (ISO calendar). Time (millisecond precision): The time-millis logical type represents a time of day, with no reference to a particular calendar, time zone or date, with a precision of one millisecond. A time-millis logical type annotates an Avro int, where the int stores the number of milliseconds after midnight, 00:00:00.000. Timestamp (millisecond precision): The timestamp-millis logical type represents an instant on the global timeline, independent of a particular time zone or calendar, with a precision of one millisecond. A timestamp-millis logical type annotates an Avro long, where the long stores the number of milliseconds from the unix epoch, 1 January 1970 00:00:00.000 UTC. UUID: Represents a uuid as a string Avro Type Logical Type Python Type int date datetime.date int time-millis datetime.time long timestamp-millis datetime.datetime string uuid uuid.uuid4","title":"Logical Types"},{"location":"fields_specification/#avro-field-and-python-types-summary","text":"Python Type Avro Type Logical Type str string do not apply int int do not apply bool boolean do not apply float float do not apply None null do not apply bytes bytes do not apply tuple enum do not apply list array do not apply dict map do not apply typing.Union union do not apply Pythin classs record do not apply datetime.date int date datetime.time int time-millis datetime.datetim long timestamp-millis uuid.uuid4 string uuid","title":"Avro Field and Python Types Summary"},{"location":"logical_types/","text":"Schema with Logical Types The following list represent the avro logical types mapped to python types: Avro Type Logical Type Python Type int date datetime.date int time-millis datetime.time long timestamp-millis datetime.datetime string uuid uuid.uuid4 Date import datetime from dataclasses_avroschema.schema_generator import SchemaGenerator a_datetime = datetime . datetime ( 2019 , 10 , 12 , 17 , 57 , 42 ) class DateLogicalType : \"Date type\" birthday : datetime . date meeting_date : datetime . date = None release_datetime : datetime . date = a_datetime . date () SchemaGenerator ( DateLogicalType ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"DateLogicalType\" , \"fields\" : [ { \"name\" : \"birthday\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"date\" } }, { \"name\" : \"meeting_date\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"date\" }, \"default\" : \"null\" }, { \"name\" : \"release_datetime\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"date\" }, \"default\" : 18181 } ], \"doc\" : \"Date type\" } ' Time import datetime from dataclasses_avroschema.schema_generator import SchemaGenerator a_datetime = datetime . datetime ( 2019 , 10 , 12 , 17 , 57 , 42 ) class TimeLogicalTypes : \"Time logical types\" birthday_time : datetime . time meeting_time : datetime . time = None release_time : datetime . time = a_datetime . time () SchemaGenerator ( TimeLogicalTypes ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"TimeLogicalTypes\" , \"fields\" : [ { \"name\" : \"birthday_time\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"time-millis\" } }, { \"name\" : \"meeting_time\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"time-millis\" }, \"default\" : \"null\" }, { \"name\" : \"release_time\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"time-millis\" }, \"default\" : 64662000 } ], \"doc\" : \"Time logical types\" } ' Datetime import datetime from dataclasses_avroschema.schema_generator import SchemaGenerator a_datetime = datetime . datetime ( 2019 , 10 , 12 , 17 , 57 , 42 ) class DatetimeLogicalType : \"Datetime logical types\" birthday : datetime . datetime meeting_time : datetime . datetime = None release_datetime : datetime . datetime = a_datetime SchemaGenerator ( DatetimeLogicalType ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"DatetimeLogicalType\" , \"fields\" : [ { \"name\" : \"birthday\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" } }, { \"name\" : \"meeting_time\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" }, \"default\" : \"null\" }, { \"name\" : \"release_datetime\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" }, \"default\" : 1570903062000.0 } ], \"doc\" : \"Datetime logical types\" } ' UUID import uuid from dataclasses_avroschema.schema_generator import SchemaGenerator class UUIDLogicalTypes : \"UUID logical types\" uuid_1 : uuid . uuid4 uuid_2 : uuid . uuid4 = None event_uuid : uuid . uuid4 = uuid . uuid4 () SchemaGenerator ( UUIDLogicalTypes ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UUIDLogicalTypes\" , \"fields\" : [ { \"name\" : \"uuid_1\" , \"type\" : { \"type\" : \"string\" , \"logicalType\" : \"uuid\" } }, { \"name\" : \"uuid_2\" , \"type\" : { \"type\" : \"string\" , \"logicalType\" : \"uuid\" }, \"default\" : \"null\" }, { \"name\" : \"event_uuid\" , \"type\" : { \"type\" : \"string\" , \"logicalType\" : \"uuid\" }, \"default\" : \"ad0677ab-bd1c-4383-9d45-e46c56bcc5c9\" } ], \"doc\" : \"UUID logical types\" } '","title":"Logical Types"},{"location":"logical_types/#schema-with-logical-types","text":"The following list represent the avro logical types mapped to python types: Avro Type Logical Type Python Type int date datetime.date int time-millis datetime.time long timestamp-millis datetime.datetime string uuid uuid.uuid4","title":"Schema with Logical Types"},{"location":"logical_types/#date","text":"import datetime from dataclasses_avroschema.schema_generator import SchemaGenerator a_datetime = datetime . datetime ( 2019 , 10 , 12 , 17 , 57 , 42 ) class DateLogicalType : \"Date type\" birthday : datetime . date meeting_date : datetime . date = None release_datetime : datetime . date = a_datetime . date () SchemaGenerator ( DateLogicalType ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"DateLogicalType\" , \"fields\" : [ { \"name\" : \"birthday\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"date\" } }, { \"name\" : \"meeting_date\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"date\" }, \"default\" : \"null\" }, { \"name\" : \"release_datetime\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"date\" }, \"default\" : 18181 } ], \"doc\" : \"Date type\" } '","title":"Date"},{"location":"logical_types/#time","text":"import datetime from dataclasses_avroschema.schema_generator import SchemaGenerator a_datetime = datetime . datetime ( 2019 , 10 , 12 , 17 , 57 , 42 ) class TimeLogicalTypes : \"Time logical types\" birthday_time : datetime . time meeting_time : datetime . time = None release_time : datetime . time = a_datetime . time () SchemaGenerator ( TimeLogicalTypes ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"TimeLogicalTypes\" , \"fields\" : [ { \"name\" : \"birthday_time\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"time-millis\" } }, { \"name\" : \"meeting_time\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"time-millis\" }, \"default\" : \"null\" }, { \"name\" : \"release_time\" , \"type\" : { \"type\" : \"int\" , \"logicalType\" : \"time-millis\" }, \"default\" : 64662000 } ], \"doc\" : \"Time logical types\" } '","title":"Time"},{"location":"logical_types/#datetime","text":"import datetime from dataclasses_avroschema.schema_generator import SchemaGenerator a_datetime = datetime . datetime ( 2019 , 10 , 12 , 17 , 57 , 42 ) class DatetimeLogicalType : \"Datetime logical types\" birthday : datetime . datetime meeting_time : datetime . datetime = None release_datetime : datetime . datetime = a_datetime SchemaGenerator ( DatetimeLogicalType ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"DatetimeLogicalType\" , \"fields\" : [ { \"name\" : \"birthday\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" } }, { \"name\" : \"meeting_time\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" }, \"default\" : \"null\" }, { \"name\" : \"release_datetime\" , \"type\" : { \"type\" : \"long\" , \"logicalType\" : \"timestamp-millis\" }, \"default\" : 1570903062000.0 } ], \"doc\" : \"Datetime logical types\" } '","title":"Datetime"},{"location":"logical_types/#uuid","text":"import uuid from dataclasses_avroschema.schema_generator import SchemaGenerator class UUIDLogicalTypes : \"UUID logical types\" uuid_1 : uuid . uuid4 uuid_2 : uuid . uuid4 = None event_uuid : uuid . uuid4 = uuid . uuid4 () SchemaGenerator ( UUIDLogicalTypes ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"UUIDLogicalTypes\" , \"fields\" : [ { \"name\" : \"uuid_1\" , \"type\" : { \"type\" : \"string\" , \"logicalType\" : \"uuid\" } }, { \"name\" : \"uuid_2\" , \"type\" : { \"type\" : \"string\" , \"logicalType\" : \"uuid\" }, \"default\" : \"null\" }, { \"name\" : \"event_uuid\" , \"type\" : { \"type\" : \"string\" , \"logicalType\" : \"uuid\" }, \"default\" : \"ad0677ab-bd1c-4383-9d45-e46c56bcc5c9\" } ], \"doc\" : \"UUID logical types\" } '","title":"UUID"},{"location":"primitive_types/","text":"Primitive Types The following list represent the avro primitive types mapped to python types: Avro Type Python Type string str int int boolean bool float float null None bytes wip Example: from dataclasses_avroschema.schema_generator import SchemaGenerator class User : \"An User\" name : str age : int is_student : bool money_available : float SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"is_student\" , \"type\" : \"boolean\" }, { \"name\" : \"money_available\" , \"type\" : \"float\" } ], \"doc\" : \"An User\" } ' Example with defaults: from dataclasses_avroschema.schema_generator import SchemaGenerator class User : \"An User\" name : str = None age : int = None is_student : bool = None money_available : float = None SchemaGenerator ( User ) . avro_schema () # We can see the use of null in the schema generated: '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : \"null\" }, { \"name\" : \"age\" , \"type\" : [ \"null\" , \"int\" ], \"default\" : \"null\" }, { \"name\" : \"is_student\" , \"type\" : [ \"null\" , \"boolean\" ], \"default\" : \"null\" }, { \"name\" : \"money_available\" , \"type\" : [ \"null\" , \"float\" ], \"default\" : \"null\" } ], \"doc\" : \"An User\" } ' # Or with null as a second type argument: class User : \"An User\" name : str = 'Juan' age : int = 20 is_student : bool = True money_available : float = 100.2 SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : [ \"string\" , \"null\" ], \"default\" : \"Juan\" }, { \"name\" : \"age\" , \"type\" : [ \"int\" , \"null\" ], \"default\" : 20 }, { \"name\" : \"is_student\" , \"type\" : [ \"boolean\" , \"null\" ], \"default\" : true }, { \"name\" : \"money_available\" , \"type\" : [ \"float\" , \"null\" ], \"default\" : 100.2 } ], \"doc\" : \"An User\" } '","title":"Primitive Types"},{"location":"primitive_types/#primitive-types","text":"The following list represent the avro primitive types mapped to python types: Avro Type Python Type string str int int boolean bool float float null None bytes wip Example: from dataclasses_avroschema.schema_generator import SchemaGenerator class User : \"An User\" name : str age : int is_student : bool money_available : float SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"is_student\" , \"type\" : \"boolean\" }, { \"name\" : \"money_available\" , \"type\" : \"float\" } ], \"doc\" : \"An User\" } ' Example with defaults: from dataclasses_avroschema.schema_generator import SchemaGenerator class User : \"An User\" name : str = None age : int = None is_student : bool = None money_available : float = None SchemaGenerator ( User ) . avro_schema () # We can see the use of null in the schema generated: '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : \"null\" }, { \"name\" : \"age\" , \"type\" : [ \"null\" , \"int\" ], \"default\" : \"null\" }, { \"name\" : \"is_student\" , \"type\" : [ \"null\" , \"boolean\" ], \"default\" : \"null\" }, { \"name\" : \"money_available\" , \"type\" : [ \"null\" , \"float\" ], \"default\" : \"null\" } ], \"doc\" : \"An User\" } ' # Or with null as a second type argument: class User : \"An User\" name : str = 'Juan' age : int = 20 is_student : bool = True money_available : float = 100.2 SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : [ \"string\" , \"null\" ], \"default\" : \"Juan\" }, { \"name\" : \"age\" , \"type\" : [ \"int\" , \"null\" ], \"default\" : 20 }, { \"name\" : \"is_student\" , \"type\" : [ \"boolean\" , \"null\" ], \"default\" : true }, { \"name\" : \"money_available\" , \"type\" : [ \"float\" , \"null\" ], \"default\" : 100.2 } ], \"doc\" : \"An User\" } '","title":"Primitive Types"},{"location":"schema_relationships/","text":"Schema Relationships OneToOne An User has one Address example: from dataclasses_avroschema.schema_generator import SchemaGenerator class Address : \"An Address\" street : str street_number : int class User : \"An User with Address\" name : str age : int address : Address SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"address\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"int\" } ], \"doc\" : \"An Address\" } } ], \"doc\" : \"An User with Address\" } ' OneToOne Recursive Schema Relationship An User with only one friend :-( : import typing from dataclasses_avroschema.schema_generator import SchemaGenerator class User : \"User with self reference as friend\" name : str age : int friend : typing . Type [ \"User\" ] schema = SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"friend\" , \"type\" : \"User\" } ], \"doc\" : \"User with self reference as friend\" } ' OneToMany Schema Relationship An User has multiple Address example: import typing from dataclasses_avroschema.schema_generator import SchemaGenerator class Address : \"An Address\" street : str street_number : int class User : \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"addresses\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"int\" } ], \"doc\" : \"An Address\" }, \"name\" : \"address\" } } ], \"doc\" : \"User with multiple Address\" } ' or OneToMany using a Map: import typing from dataclasses_avroschema.schema_generator import SchemaGenerator class Address : \"An Address\" street : str street_number : int class User : \"User with multiple Address\" name : str age : int addresses : typing . Dict [ str , Address ] SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"addresses\" , \"type\" : { \"type\" : \"map\" , \"values\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"int\" } ], \"doc\" : \"An Address\" }, \"name\" : \"address\" } } ], \"doc\" : \"User with multiple Address\" } ' OneToMany Recursive Schema Relationship An User with multiple friends :-) : import typing from dataclasses_avroschema.schema_generator import SchemaGenerator # Using a List (Avro Array) class User : \"User with self reference as friends\" name : str age : int friends : typing . List [ typing . Type [ \"User\" ]] schema = SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"friends\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"User\" , \"name\" : \"friend\" } } ], \"doc\" : \"User with self reference as friends\" } ' # Using a Dict (Avro Map) class User : \"User with self reference as friends\" name : str age : int friends : typing . Dict [ str , typing . Type [ \"User\" ]] schema = SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"friends\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"User\" , \"name\" : \"friend\" } } ], \"doc\" : \"User with self reference as friends\" } '","title":"Schema Relationships"},{"location":"schema_relationships/#schema-relationships","text":"","title":"Schema Relationships"},{"location":"schema_relationships/#onetoone","text":"An User has one Address example: from dataclasses_avroschema.schema_generator import SchemaGenerator class Address : \"An Address\" street : str street_number : int class User : \"An User with Address\" name : str age : int address : Address SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"address\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"int\" } ], \"doc\" : \"An Address\" } } ], \"doc\" : \"An User with Address\" } '","title":"OneToOne"},{"location":"schema_relationships/#onetoone-recursive-schema-relationship","text":"An User with only one friend :-( : import typing from dataclasses_avroschema.schema_generator import SchemaGenerator class User : \"User with self reference as friend\" name : str age : int friend : typing . Type [ \"User\" ] schema = SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"friend\" , \"type\" : \"User\" } ], \"doc\" : \"User with self reference as friend\" } '","title":"OneToOne Recursive Schema Relationship"},{"location":"schema_relationships/#onetomany-schema-relationship","text":"An User has multiple Address example: import typing from dataclasses_avroschema.schema_generator import SchemaGenerator class Address : \"An Address\" street : str street_number : int class User : \"User with multiple Address\" name : str age : int addresses : typing . List [ Address ] SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"addresses\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"int\" } ], \"doc\" : \"An Address\" }, \"name\" : \"address\" } } ], \"doc\" : \"User with multiple Address\" } ' or OneToMany using a Map: import typing from dataclasses_avroschema.schema_generator import SchemaGenerator class Address : \"An Address\" street : str street_number : int class User : \"User with multiple Address\" name : str age : int addresses : typing . Dict [ str , Address ] SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"addresses\" , \"type\" : { \"type\" : \"map\" , \"values\" : { \"type\" : \"record\" , \"name\" : \"Address\" , \"fields\" : [ { \"name\" : \"street\" , \"type\" : \"string\" }, { \"name\" : \"street_number\" , \"type\" : \"int\" } ], \"doc\" : \"An Address\" }, \"name\" : \"address\" } } ], \"doc\" : \"User with multiple Address\" } '","title":"OneToMany Schema Relationship"},{"location":"schema_relationships/#onetomany-recursive-schema-relationship","text":"An User with multiple friends :-) : import typing from dataclasses_avroschema.schema_generator import SchemaGenerator # Using a List (Avro Array) class User : \"User with self reference as friends\" name : str age : int friends : typing . List [ typing . Type [ \"User\" ]] schema = SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"friends\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"User\" , \"name\" : \"friend\" } } ], \"doc\" : \"User with self reference as friends\" } ' # Using a Dict (Avro Map) class User : \"User with self reference as friends\" name : str age : int friends : typing . Dict [ str , typing . Type [ \"User\" ]] schema = SchemaGenerator ( User ) . avro_schema () '{ \"type\" : \"record\" , \"name\" : \"User\" , \"fields\" : [ { \"name\" : \"name\" , \"type\" : \"string\" }, { \"name\" : \"age\" , \"type\" : \"int\" }, { \"name\" : \"friends\" , \"type\" : { \"type\" : \"map\" , \"values\" : \"User\" , \"name\" : \"friend\" } } ], \"doc\" : \"User with self reference as friends\" } '","title":"OneToMany Recursive Schema Relationship"}]}